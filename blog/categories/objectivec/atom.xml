<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objectivec | Away0x's Blog]]></title>
  <link href="http://away0x.github.io/blog/categories/objectivec/atom.xml" rel="self"/>
  <link href="http://away0x.github.io/"/>
  <updated>2021-04-27T10:39:58+08:00</updated>
  <id>http://away0x.github.io/</id>
  <author>
    <name><![CDATA[TongWu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ObjectiveC - 单例]]></title>
    <link href="http://away0x.github.io/blog/2018/02/16/oc-singleton/"/>
    <updated>2018-02-16T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2018/02/16/oc-singleton</id>
    <content type="html"><![CDATA[<!-- more -->


<p>单例可以保证在程序运行过程，一个类只有一个实例，而且该实例易于供外界访问从而方便地控制了实例个数，并节约系统资源</p>

<p>使用场合: 在整个应用程序中，共享一份资源 (这份资源只需要创建初始化一次)</p>

<ul>
<li><a href="#arc">ARC环境下实现单例模式</a></li>
<li><a href="#mrc">MRC环境下实现单例模式</a></li>
<li><a href="#am">ARC与MRC通用的单例</a></li>
</ul>


<h1><h2 id="arc">ARC 环境下实现单例模式</h2></h1>

<pre><code class="objectivec">// 懒加载的单例的写法

@implementation Demo

// 提供全局变量
static Demo *_instance;

+ (instancetype)allocWithZone:(struct _NSZone *)zone {
    if (_instance == nil) {
        _instance = [super allocWithZone:zone];
    }
    return _instance;
}
@end
</code></pre>

<pre><code class="objectivec">// 使用

Demo *d1 = [[Demo alloc]init];
Demo *d2 = [[Demo alloc]init];
Demo *d3 = [Demo new];

NSLog(@"d1:%p d2:%p d3:%p", d1, d2, d3); // 可见地址都一样
</code></pre>

<p>使用懒加载的写法，如外界在很多子线程中 alloc，那么会有安全隐患问题</p>

<h2>解决多线程下的隐患</h2>

<pre><code class="objectivec">// 方法一: 加互斥锁，解决多线程访问安全问题

@implementation Demo

static Demo *_instance;

+ (instancetype)allocWithZone:(struct _NSZone *)zone {
    @synchronized(self) {
       if (_instance == nil) {
            _instance = [super allocWithZone:zone];
        }
    }
    return _instance; 
}
@end
</code></pre>

<pre><code class="objectivec">// 方法二: GCD 一次性代码，保证整个程序运行中，只执行一次，且线程安全

@implementation Demo

static Demo *_instance;

+ (instancetype)allocWithZone:(struct _NSZone *)zone {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        _instance = [super allocWithZone:zone];
    });

    return _instance; 
}
@end
</code></pre>

<h2>优化</h2>

<ul>
<li>为了外部方便调用，可像外部提供一个类方法，便于使用单例

<ul>
<li>方法名: <code>share + 类名</code> | <code>default + 类名</code> | <code>类名</code></li>
</ul>
</li>
</ul>


<pre><code class="objectivec">@interface Demo : NSObject

+ (instancetype)shareDemo;

@end

@implementation Demo

static Demo *_instance;

+ (instancetype)allocWithZone:(struct _NSZone *)zone {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        _instance = [super allocWithZone:zone];
    });

    return _instance; 
}

// 提供类方法，方便外界访问
+ (instancetype)shareDemo {
    // 调用 alloc 时，会调用 allocWithZone
    return [[self aloc]init];
}

// 严谨: 由于下面这两个方法也可获取到对象
// 所以也需重写一下，让他们得到的也是单例对象
- (id)copyWithZone:(NSZone *)zone {
    return _instance;
}
- (id)mutableCopyWithZone:(NSZone *)zone {
    return _instance;
}

@end
</code></pre>

<pre><code class="objectivec">// 使用

Demo *d1 = [Demo shareDemo];
Demo *d2 = [Demo new];
Demo *d3 = [Demo shareDemo];
Demo *d4 = [d1 copy];
Demo *d5 = [d1 mutableCopy];

NSLog(@"d1:%p d2:%p d3:%p d4:%p d5:%p", d1, d2, d3, d4, d5); // 可见地址都一样
</code></pre>

<h1><h2 id="mrc">MRC 环境下实现单例模式</h2></h1>

<pre><code class="objectivec">@implementation Demo

// 实现同 ARC 单例

#pragma mark - MRC中需要覆盖的方法
// 不需要计数器+1
- (id)retain {
    return self;
}

// 不需要，堆区的对象才需要
- (id)autorelease {
    return self;
}

// 不需要
- (oneway void)release {}

// 不需要计数器个数， 直接返回最大无符号整数
- (NSUInteger)retainCount {
    return UINT_MAX;  // 参照常量区字符串的 retainCount
}
@end
</code></pre>

<h1><h2 id="am">ARC 与 MRC 通用的单例</h2></h1>

<pre><code class="objectivec">@interface Demo : NSObject

+ (instancetype)shareDemo;

@end

@implementation Demo

static Demo *_instance;

+ (instancetype)allocWithZone:(struct _NSZone *)zone {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        _instance = [super allocWithZone:zone];
    });

    return _instance; 
}

// 提供类方法，方便外界访问
+ (instancetype)shareDemo {
    // 调用 alloc 时，会调用 allocWithZone
    return [[self aloc]init];
}

- (id)copyWithZone:(NSZone *)zone {
    return _instance;
}
- (id)mutableCopyWithZone:(NSZone *)zone {
    return _instance;
}

// 通过宏定义判断是否为 MRC 环境
#pragma mark - MRC 中需要覆盖的方法, ARC与MRC的整合  
#if !__has_feature(objc_arc)

- (id)retain {
    return self;
}

- (id)autorelease {
    return self;
}

- (oneway void)release {}

- (NSUInteger)retainCount {
    return UINT_MAX;
}  

#endif

@end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectiveC - Tricks]]></title>
    <link href="http://away0x.github.io/blog/2018/02/15/oc-tricks/"/>
    <updated>2018-02-15T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2018/02/15/oc-tricks</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#clserror">写类时的常见错误</a></li>
<li><a href="#const">常量</a></li>
<li><a href="#precompile">预编译</a></li>
<li><a href="#ssc">super &amp; superclass &amp; class</a></li>
<li><a href="#lazy">懒加载</a></li>
<li><a href="#foreach">foreach</a></li>
<li><a href="#timer">timer</a></li>
<li><a href="#predicate">predicate</a></li>
<li><a href="#ec">expression closures</a></li>
</ul>


<h1><h2 id="clserror">写类时的常见错误</h2></h1>

<ol>
<li>只有类的声明没有实现</li>
<li>漏了 @end</li>
<li>@interface 和 @implementation 嵌套</li>
<li>实例变量没有写在声明的大括号内</li>
<li>方法的声明写在了大括号内</li>
<li>实例变量不能再大括号内初始化、和访问权限的问题</li>
<li>方法不能当做函数一样调用</li>
<li>OC 方法不能独立于类存在</li>
<li>C 函数不属于类，C 函数只归定义函数的文件所有</li>
<li>C 函数不能访问 OC 对象的成员</li>
<li>方法有声明，但实现时写成了函数</li>
<li>static 不能用在实例变量和方法上，不要和 C 语言混淆</li>
</ol>


<h1><h2 id="const">常量</h2></h1>

<p>尽量使用类型常量，而不是使用宏定义</p>

<pre><code class="objectivec">// 定义字符串常量
static NSString * const STMProjectName = @"GCDFetchFeed";
</code></pre>

<h1><h2 id="precompile">预编译</h2></h1>

<pre><code class="objectivec">// 只在 mac 系统下输出
#if TARGET_OS_MAC
    NSLog(@"这是 mac 系统");
#endif

#define DEBUG_MODE 1
#if DEBUG_MODE
    NSLog(@"当前是调试模式"); // 输出这条
#else
    NSLog(@"当前不是调试模式");
#endif

#ifdef XX
    // 如果定义了 XX ，才会执行这里的代码
#endif
</code></pre>

<h1><h2 id="ssc">super &amp; superclass &amp; class</h2></h1>

<ul>
<li>class: 获取当前方法调用者的类</li>
<li>superclass: 获取当前方法调用者的父类</li>
<li>super: 仅仅是一个编译指示器，就是给编译器看的，不是一个指针

<ul>
<li>这和 super 不一样，self 是一个指针</li>
<li><code>NSLog(@"%@ %@", self, super)</code> 所以打印 self 可以，但是打印 super 会报错</li>
<li>只要编译器看到 super 这个标志，就会让当前对象去调用父类方法，<strong>本质还是当前对象在调用</strong>

<ul>
<li>所以 <code>[super class]</code> 等同于 <code>[self class]</code></li>
</ul>
</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">// SubPerson 继承了 Person

@implementation SubPerson

- (void)test {
    NSLog(
        @"%@ %@ %@ %@",
        [self class],      // SubPerson
        [self superclass], // Person
        [super class],     // SubPerson
        [super superclass] // Person
    );
}

@end
</code></pre>

<h1><h2 id="lazy">懒加载</h2></h1>

<ul>
<li>本质是重写 getter 方法。用到时候再加载，而且只加载一次</li>
<li>代码创建 UI 常用懒加载</li>
</ul>


<pre><code class="objectivec">// 以懒加载一个UIImageView控件为例
- (UIImageView *)imageView {
    if ( ! _imageView) {
        _imageView = [[UIImageView alloc]init];
        // 设置 属性
    }
    return _imageView;
}
</code></pre>

<h1><h2 id="foreach">foreach</h2></h1>

<pre><code class="objectivec">// 让数组中的每个元素都执行 removeFromSuperview 该方法
[self.view.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];
</code></pre>

<h1><h2 id="timer">timer</h2></h1>

<pre><code class="objectivec">// ---------------- 头文件 ----------------------
@interface MyTimer : NSObject
- (void) testTimer;
@end

// ---------------- 实现文件 ----------------------
// 定义定时器
@interface MyTimer() {
    NSTimer *timer1;
    NSTimer *timer2;
}

@end

@implementation MyTimer
- (void) testTimer {
    // 1. 手动添加到 RunLoop
    // 参数1：中断间隔，参数2：响应方法对象，参数3：响应方法，参数4：传递参数，参数5：是否重复
    timer1 = [NSTimer timerWithTimeInterval: 1 target: self selector: @selector(myLog) userInfo:
        nil repeats: false];
    [[NSRunLoop currentRunLoop] addTimer: timer1 forMode: NSDefaultRunLoopMode];
    [[NSRunLoop currentRunLoop] run];

    // 2. 自动添加到 RunLoop + 带参定时器
    // 用这个方法的话，如当前线程中有 RunLoop，则会自动添加进去
    timer2 = [NSTimer scheduledTimerWithTimeInterval: 1 target: self selector: @selector(myLog:)
        userInfo: @"world" repeats: false];
    [timer2 fire];

    // 3. 定时精度 0.01s = 10ms = 0.01 * 1000 只能粗略的计算
    timer1 = [NSTimer timerWithTimeInterval: 0.01 target: self selector: @selector(myLog) userInfo:
        nil repeats: true];
    [[NSRunLoop currentRunLoop] addTimer: timer1 forMode: NSDefaultRunLoopMode];
    [[NSRunLoop currentRunLoop] run];

    // 4. 如何快速的打印出当前代码的执行时间
    NSDate *timerMark = [NSDate date]; // 当前时间
    // 要执行的代码放这中间......
    NSTimeInterval timerInterval = [timeMark timeIntervalSinceNow]; // 执行结束时间
    float timeNow = 0 - timeInterval; // 时间转为正数
    NSLog(@"timeNow=%f", timeNow);
}
- (void) myLog {
    NSLog(@"我是一个定时器");
}
// 带参数的定时器
- (void) myLog:(NSTimer*)timer {
    NSLog(@"hello %@", timer2.userInfo); // "hello world"
}
@end

// ---------------- 执行文件 ----------------------
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        MyTimer *timer = [[MyTimer alloc] init];
        [timer testTimer];
    }
}
</code></pre>

<h1><h2 id="predicate">predicate</h2></h1>

<p>按一定的条件对数据进行处理和过滤</p>

<pre><code class="objectivec">// 对数组中的元素进行过滤

NSArray *arr1 = [[NSArray
    alloc] initWithObjects:@"ios",@"android",@"wp", nil];

// 1. 创建谓词对象 2. 指定过滤条件
NSPredicate *pre1 = [NSPredicate
    predicateWithFormat:@"SELF == 'android'"]; // SELF 是数组的每一项
// 3. 过滤条件应用到对象上
NSArray *arr2 = [arr1 filteredArrayUsingPredicate:pre1];

for (NSString *item in arr2) {
    NSLog(@"%@", item); // android
}
</code></pre>

<pre><code class="objectivec">// 得到数组中大于 10 的元素

NSString *num1 = [NSString stringWithFormat:@"%d", 3];
NSString *num2 = [NSString stringWithFormat:@"%d", 15];

NSArray *arr1 = [[NSArray alloc] initWithObjects:num1,num2, nil];

// 使用谓词
NSPredicate *pre1 = [NSPredicate
    predicateWithFormat:@"SELF.initValue &gt; 10"];
NSArray *arr2 = [arr1 filteredArrayUsingPredicate:pre1];

for (NSString *item in arr2) {
    NSLog(@"%d", item.initValue); // 15
}
</code></pre>

<pre><code class="objectivec">// 谓词关键词
// 数组中是否包含某个元素(使用关键词)

NSArray *arr1 = [[NSArray alloc] initWithObjects:@"abc",@"def", nil];

NSPredicate *pre1 = [NSPredicate
    predicateWithFormat:@"SELF CONTAINS %@",@"def"]; // CONTAINS: SELF 包含某些内容
NSArray *arr2 = [arr1 filteredArrayUsingPredicate:pre1];

for (NSString *item in arr2) {
    NSLog(@"%@", item); // "def"
}
</code></pre>

<pre><code class="objectivec">// 过滤对象
// 过滤出 age 属性为 10 的对象
Person *p1 = [[Person alloc] init];
p1.age = 10;
Person *p2 = [[Person alloc] init];
p2.age = 30;

NSMutableArray *arr1 = [[NSMutableArray alloc] init];
[arr1 addObject:p1];
[arr1 addObject:p2];
NSLog(@"%p %p", p1, p2); // 打印地址

NSPredicate *pre1 = [NSPredicate
    predicateWithFormat:@"age == %d",10];
NSArray *arr2 = [arr1 filteredArrayUsingPredicate:pre1];

for (Person *p in arr2) {
    NSLog(@"%p", p); // 打印地址
}
</code></pre>

<h1><h2 id="ec">expression closures</h2></h1>

<pre><code class="objectivec">// 会将代码块 ({}) 里最后一个表达式 return 出来

#define ScreenWidth [UIScreen mainScreen].bounds.size.width
static NSString * const ID = @"cell";

// UICollectionView 布局
UICollectionViewFlowLayout *layout = ({
    UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc]init];
    layout.itemSize = CGSizeMake(160, 160);
    layout.minimumLineSpacing = 50; // 最小行间距
    // layout.minimumInteritemSpacing = 0; // item 的最小间距
    layout.scrollDirection = UICollectionViewScrollDirectionHorizontal; // 滚动方向
    // 内边距
    CGFloat margin = (ScreenWidth - 160) * 0.5;
    layout.sectionInset = UIEdgeInsetsMake(0, margin, 0, margin);

    layout; // 相当于将这个值 return 出去了
});

// UICollectionView 创建
UICollectionView *collectionView = ({
    UICollectionView *collectionView = [[UICollectionView alloc]initWithFrame:CGRectZero collectionViewLayout:layout];
    collectionView.backgroundColor = [UIColor brownColor];
    collectionView.center = self.view.center;
    collectionView.bounds = CGRectMake(0, 0, self.view.bounds.size.width, 200);
    collectionView.dataSource = self;
    collectionView.showsHorizontalScrollIndicator = NO; // 隐藏水平滚动条

    collectionView; // 相当于将这个值 return 出去了
});

// 注册 cell
[collectionView
    registerNib:[UINib nibWithNibName:
        NSStringFromClass([MyCollectionViewCell class]) bundle:nil]
    forCellWithReuseIdentifier:ID];

[self.view addSubview:collectionView];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectiveC - Typedef, Generic, Enum, @class]]></title>
    <link href="http://away0x.github.io/blog/2018/02/11/oc-typedef-generic-enum-class/"/>
    <updated>2018-02-11T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2018/02/11/oc-typedef-generic-enum-class</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#typedef">typedef</a></li>
<li><a href="#generic">generic</a></li>
<li><a href="#enum">enum</a></li>
<li><a href="#class">@class</a></li>
</ul>


<h1><h2 id="typedef">typedef</h2></h1>

<pre><code class="objectivec">// 未使用别名
enum IColor {
    kIColorBlack,
    kIColorWhite
}

@interface Iphone : NSObject {
    enum IColor _color; // 类型名很长
}

@end

@implementation Iphone

@end

// 使用别名
typedef enum {
    kIColorBlack,
    kIColorWhite
} IColor;

@interface Iphone : NSObject {
    IColor _color; // 使用类型别名
}

@end

@implementation Iphone

@end

// 使用
int main(int argc, const char * argv[]) {
    Iphone *p = [Iphone new];
    p-&gt;_color = kIColorBlack;

    return 0;
}
</code></pre>

<h1><h2 id="generic">generic</h2></h1>

<blockquote><p>iOS9+</p></blockquote>

<ol>
<li>用于限制类型</li>
<li>提高代码规划，减少沟通成本</li>
<li>限制集合里的存储类型，不限制的话都是 id 类型

<ul>
<li>限制后只能存储对应类型，且由于有了具体类型，取出时可以使用点语法</li>
<li>id 类型是不能使用点语法的</li>
</ul>
</li>
<li>泛型仅仅是报警告</li>
</ol>


<pre><code class="objectivec">// 不用泛型 --------
// 属性
@property (nonatomic, strong) NSMutableArray *arr;

// 使用
[_arr addObject:@"112"]; // 由于定义时没用泛型，所以这里 add 进去的其实是 id 类型
_arr[0].length; // 报错，_arr[0] 里面是 id 类型，id 类型不能使用点语法

// 使用泛型 --------
// 属性
@property (nonatomic, strong) NSMutableArray&lt;NSString *&gt; *arr;

// 使用
[_arr addObject:@"112"]; // add 的是 NSString 类型
_arr[0].length; // 不报错，数组里是 NSString 类型
</code></pre>

<pre><code class="objectivec">// 参数
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
</code></pre>

<pre><code class="objectivec">// 限定类型
@interface Test&lt;ObjectType&gt; : NSObject
@property (nonatomic, strong) ObjectType language;
@end

// 使用
Java *java = [[Java alloc] init];
iOS *ios = [[iOS alloc] init];

Test&lt;iOS *&gt; *t = [[Test alloc] init];
t.language = ios;  // 泛型限制了，这里只能设置 iOS 类型
t.language = java; // 报警告
</code></pre>

<h1><h2 id="enum">enum</h2></h1>

<pre><code class="objectivec">// 第一种写法 (无法设置枚举值类型)
typedef enum {
    DemoTypeTop,
    DemoTypeBottom,
} DemoType;

// 第二种写法 (可设置枚举值类型)
typedef NS_ENUM(NSInteger, DemoType) {
    DemoTypeTop,
    DemoTypeBottom,
};

// 第三种写法 (位移枚举)
// 更强大，使用时可用并运算
typedef NS_OPTIONS(NSInteger, DemoType) {
    DemoTypeTop = 1 &lt;&lt; 0,    // 1*2^0 = 1
    DemoTypeBottom = 1 &lt;&lt; 1, // 1*2^1 = 2
    DemoTypeLeft = 1 &lt;&lt; 2,   // 1*2^2 = 4
    DemoTypeRight = 1 &lt;&lt; 3,  // 1*2^3 = 8
};
</code></pre>

<p>位移枚举可进行位运算</p>

<pre><code class="objectivec">// 按位与 &amp;
//    1&amp;1==1 1&amp;0==0 0&amp;0==0
//    总结: 只有有 0 则为 0
// 按位或 |
//    1|1==1 1|0==1 0|0==0
//    总结: 只有有 1 则为 1

- (void)demo:(DemoType)type {
    if (type &amp; DemoTypeTop) {
        NSLog(@"top --- %zd", type &amp; DemoTypeTop);
    }
    if (type &amp; DemoTypeBottom) {
        NSLog(@"bottom --- %zd", type &amp; DemoTypeBottom);
    }
    if (type &amp; DemoTypeLeft) {
        NSLog(@"left --- %zd", type &amp; DemoTypeLeft);
    }
    if (type &amp; DemoTypeRight) {
        NSLog(@"right --- %zd", type &amp; DemoTypeRight);
    }
}

- (void)test {
    [self demo:DemoTypeTop | DemoTypeRight]; // 打印 top 和 right
    [self demo:0]; // 什么都不会打印

    // 小技巧
    // 如是位移枚举，可观察第一个枚举值，如该枚举值不为 0
    // 那么可默认传 0 做参数，如传 0，那么效率最高 (因为什么额外操作都不会做)
}
</code></pre>

<h2>枚举中的位运算</h2>

<ul>
<li>位移枚举，可以使用并运算 <code>|</code></li>
<li>一般情况下，如方法参数是枚举值，那么可用过 <code>|</code> 符号，连接多个枚举值</li>
</ul>


<pre><code class="objectivec">NSDate *now = [NSDate date];
NSCalendar *calendar = [NSCalendar currentCalendar];

// 分别获取 年月日时分秒
// 如方法参数是位移枚举，那么可用过 | 符号，连接多个枚举值
NSCalendarUnit type = NSCalendarUnitYear |
                      NSCalendarUnitMonth |
                      NSCalendarUnitDay |
                      NSCalendarUnitHour |
                      NSCalendarUnitMinute |
                      NSCalendarUnitSecond;
NSDateComponents *cmps = [calendar components:type fromDate:now];
NSLog(@"year = %ld", cmps.year);
NSLog(@"month = %ld", cmps.month);
NSLog(@"day = %ld", cmps.day);
NSLog(@"hour = %ld", cmps.hour);
NSLog(@"minute = %ld", cmps.minute);
NSLog(@"second = %ld", cmps.second);
</code></pre>

<h1><h2 id="class">@class</h2></h1>

<p>作用: 可以简单的引用一个类</p>

<ul>
<li><p>简单使用: <code>@class Dog;</code> 仅仅是告诉编译器: Dog 是一个类，并不会包含 Dog 这个类的所有内容</p></li>
<li><p><code>@class:</code> 在 <code>.h</code> 文件中使用 <code>@class</code> 引用一个类</p>

<ul>
<li>仅仅只是告诉编译器，<code>@class</code>后面的名称是一个类，不会做任何拷贝操作</li>
<li>注意: 编译器不会知道这个类中有哪些属性和方法，所以在 <code>.m</code> 中使用这个类时，需要 import 这个类，才能使用</li>
</ul>
</li>
<li><code>#import:</code>在 <code>.m</code> 文件中使用 <code>#import</code> 包含这个类的 <code>.h</code> 文件

<ul>
<li>会将整个文件的代码拷贝到 import 所在的位置</li>
<li>只要 import 的文件发生了改变，那么 import 就会重新拷贝一次 (更新操作)

<ul>
<li>多个类时，编译效率变慢</li>
</ul>
</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">// Person2.h 中
@class Person1; // 该文件中引入 Person1 类

// Person2.m 中
#import "Person1.h"
</code></pre>

<p>如果在 A 类中要包含 B类，B 类中又要包含 A 类，则 <code>.h</code> 中一定要用 <code>@class</code> 避免循环引入</p>

<ul>
<li>总结:

<ol>
<li>在 <code>.h</code> 中使用 <code>@class</code> 引用一个类</li>
<li>在 <code>.m</code> 文件中使用 <code>#import</code> 包含这个类的 <code>.h</code> 文件</li>
</ol>
</li>
</ul>


<h2>@class 其他应用场景</h2>

<p>对于循环依赖关系来说，比方 A 类引用 B 类，同时 B 类也引用 A 类</p>

<pre><code class="objectivec">// 这种嵌套包含的代码编译会报错
#import "B.h"
@interface A : NSObject {
    B *_b;
}
@end

#import "A.h"
@interface B : NSObject {
    A *_a;
}
@end
</code></pre>

<pre><code class="objectivec">// 当使用 @class 在两个类相互声明，就不会出现编译报错

@class B
@interface A : NSObject {
    B *_b;
}
@end

@class A
@interface B : NSObject {
    A *_a;
}
@end
</code></pre>

<h2>@class 和 #import 的区别</h2>

<ul>
<li>作用上的区别

<ul>
<li>import 会包含引用类的所有信息(内容)，包括引用类的变量和方法</li>
<li>@class 仅仅是告诉编译器有这么个类，具体这个类有什么信息，完全不知</li>
</ul>
</li>
<li>效率上的区别

<ul>
<li>如果有上百个头文件都 <code>#import</code> 了同一个文件，或者这些文件依次被 <code>#import</code>，那么一旦最开始的头文件有所改动，后面引用到这个文件的所有类都需要重新编译一遍，编译效率非常低</li>
<li>相对来讲，使用 <code>@class</code> 就不会出现这个问题了</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectiveC - Const, Static, Extern]]></title>
    <link href="http://away0x.github.io/blog/2018/02/10/oc-const-static-extern/"/>
    <updated>2018-02-10T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2018/02/10/oc-const-static-extern</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#const">const</a></li>
<li><a href="#static">static</a></li>
<li><a href="#extern">extern</a></li>
</ul>


<h1><h2 id="const">const</h2></h1>

<blockquote><p>苹果推荐使用 const 常量替代宏字符串常量</p></blockquote>

<h2>const 与宏的区别</h2>

<ol>
<li><strong>编译时刻:</strong> 宏是<strong>预编译</strong>(编译之前处理)，const 是<strong>编译阶段</strong></li>
<li><strong>编译检查:</strong> 宏不做检查，不会报编译错误，只是替换，const 会编译检查，会报编译错误</li>
<li><strong>宏的好处:</strong> 宏能定义一些函数、方法。const 则不能</li>
<li><strong>宏的坏处:</strong> 使用大量宏，容易造成编译时间久，每次都需要重新替换</li>
</ol>


<pre><code class="objectivec">// 宏
#define MyAccount @"account"
#define MyUserDefault [NSUserDefaults standardUserDefaults]

// 字符串常量
static NSString * const account = @"account";

- (void)viewDidLoad {
    [super viewDidLoad];

    // 使用宏
    [MyUserDefault setValue:@"123", forKey:MyAccount];

    // 使用 const 常量
    [[NSUserDefaults standardUserDefaults] setValue:@"123", forKey:account];
}
</code></pre>

<h2>使用</h2>

<ul>
<li>作用

<ol>
<li>修饰右边的基本变量或指针变量</li>
<li>被 cosnt 修饰的变量是只读的</li>
</ol>
</li>
<li>使用场景

<ol>
<li>修饰全局只读变量</li>
<li>修饰方法中只读参数</li>
</ol>
</li>
</ul>


<pre><code class="objectivec">int a = 3;
a = 5; // 可以修改

int const b = 3; // 也可这样写 const int b = 3;
b = 5; // 不可修改，报错
</code></pre>

<pre><code class="objectivec">// const 修饰指针变量

int a = 3;
int *p = &amp;a;
NSLog(@"%d", a); // 3
a = 5;
NSLog(@"%d", a); // 5
*p = 8;
NSLog(@"%d", a); // 8

// const 修饰 *p
int a = 3;
int b = 5;
int const *p = &amp;a;
p = &amp;b; // p 可以修改
*p = 8; // *p 被 const 修饰了，不可修改，会报错

// const 修饰 p
int a = 3;
int b = 5;
int * const p = &amp;a;
p = &amp;b; // p 被 const 修饰了，不可修改，会报错
*p = 8; // *p 可被修改
</code></pre>

<pre><code class="objectivec">int * const p;       // p: 不可修改，*p: 可修改
int const *p;        // p: 可修改，  *p: 不可修改
const int * p;       // p: 可修改，  *p: 不可修改
const int * const p; // p: 不可修改，*p: 不可修改
int const * const p; // p: 不可修改，*p: 不可修改
</code></pre>

<h1><h2 id="static">static</h2></h1>

<ol>
<li>修饰局部变量，被其修饰的局部变量，会延长生命周期，生命长度跟整个应用程序有关

<ul>
<li>被 static 修饰的局部变量，只会分配一次内存</li>
<li>被 static 修饰的局部变量，程序一运行就会给其分配内存</li>
</ul>
</li>
<li>修饰全局变量，被 static 修饰的全局变量，作用域会修改，只能在当前文件下使用</li>
</ol>


<h2>static 和 const 联合使用</h2>

<ul>
<li>cosnt 修饰全局变量，使其只读</li>
<li>static 修饰全局变量，使其作用域为文件作用域</li>
</ul>


<pre><code class="objectivec">// 只在当前文件中可访问到的只读全局变量
static NSString * const name = @"wt";

@implementation ViewController
@end
</code></pre>

<h1><h2 id="extern">extern</h2></h1>

<ol>
<li>用于声明(使用)外部全局变量，<strong>注意: 其只能用于声明，不能用于定义</strong></li>
<li>工作原理: 先会去当前文件下查找有无对应全局变量，如没有，才会去其他文件查找</li>
<li>全局变量在程序运行时就会分配，如 A 文件中定义了全局变量 <code>int a = 0</code>，在 B 文件中可用 <code>extern int a</code> 来使用它</li>
<li>如该全局变量使用 static 修饰，那么 extern 无法找到它，因为其是文件作用域</li>
</ol>


<h2>extern 和 const 联合使用</h2>

<pre><code class="objectivec">// A 类
NSString * const a = @"a";

@implementation A
@end
</code></pre>

<pre><code class="objectivec">// 使用全局变量 a
extern NSString *a;

@implementation B

- (void)test {
    NSLog(@"%@", a); // "a" 可读到
    a = @"aa";       // 报错，a 被 const 修饰了，不可修改
}

@end
</code></pre>

<h2>注意点</h2>

<ul>
<li>注意: 全局变量不能定义在自己的类中

<ul>
<li>如多个文件声明了同名的全局变量，会编译失败</li>
</ul>
</li>
<li>可自己创建一个管理全局变量的类，如 <code>GlobeConst</code>

<ul>
<li>在 m 文件中定义全局变量，在 h 中使用 extern 引用，这样其他文件要使用这些全局变量，只要引用 <code>GlobeConst.h</code> 文件即可</li>
<li><code>GlobeConst</code> 中的全局变量使用 const 修饰，避免其他文件使用时对其修改了</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">// GlobeConst.h

extern NSString * const one_name;
</code></pre>

<pre><code class="objectivec">// GlobeConst.m

NSString * const one_name = @"one name";
</code></pre>

<pre><code class="objectivec">// 其他文件

#import "GlobeConst.h"

NSLog(@"%@", one_name); // "one name"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectiveC - Property, Synthesize]]></title>
    <link href="http://away0x.github.io/blog/2018/02/09/oc-property-synthesize/"/>
    <updated>2018-02-09T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2018/02/09/oc-property-synthesize</id>
    <content type="html"><![CDATA[<!-- more -->


<blockquote><p>Xcode4.4之前 @property 用于生成实例变量 getter/setter 的声明，@synthesize 用于生成 getter/setter 的实现</p>

<p>@property 和 @synthesize 在 Xcode4.4 以前一直都是配合着使用，在 4.4 以后，@property 得到了增强，一行代码编译器就会自动帮我们生成 setter 和  getter 方法的声明和实现，同时在 m 文件中声明一个和属性名一样并且在最前面带有下划线的实例变量 (私有的)</p></blockquote>

<ul>
<li><a href="#property">Property</a></li>
<li><a href="#synthesize">Synthesize</a></li>
</ul>


<h1><h2 id="property">Property</h2></h1>

<ul>
<li>@property 是一个编译器指令</li>
<li>可以使用 @property 来代替 getter/setter 方法的声明和实现

<ul>
<li>即只要写 @property 就不用写 getter/setter 方法了</li>
<li>但 @property 生成的 getter/setter 十分简单，想增强，可自己重写</li>
<li>但如<strong>同时重写(只重写其一不会)</strong>了 getter/setter @property 就不会自动生成私有的实例变量</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">// 使用实例变量 getter/setter
@interface Person : NSObject {
    int _age;
}
// setter
- (void)setAge:(int)age;
// getter
- (int)age;
@end
</code></pre>

<pre><code class="objectivec">// 使用 property 替代 实例变量 getter/setter
@interface Person : NSObject

// 编译器只要看到 property，就做下面的事情
//    - 编译时生成一个实例变量 _age
//    - 生成 getter/setter 的声明
//    - 生成 getter/setter 的实现
@property int age; // property 名不用写下划线

@end

// 使用
Person *p = [Person new];
[p setAge:11]; // 可使用 setter 了
p.age = 11;
</code></pre>

<h2>Property 修饰符</h2>

<ul>
<li><code>@property (修饰符1, 修饰符2, ...) 数据类型 变量名;</code></li>
<li>不写修饰符默认为 <code>(atomic, assign, readwrite)</code></li>
</ul>


<h3>readwrite, readonly</h3>

<ul>
<li>readwrite: (默认) 可读可写，生成 getter/setter</li>
<li>readonly: 只读，只生成 getter</li>
<li>也可指定生成的方法的名称</li>
</ul>


<pre><code class="objectivec">@property (readonly) int age;

@property (getter=isMarried) BOOL married;
// 通常 BOOL 类型的属性的 getter 要以 is 开头
</code></pre>

<h3>getter, setter</h3>

<ul>
<li>getter: 可以给生成的 getter 方法起一个名称</li>
<li>setter: 可以给生成的 setter 方法起一个名称</li>
</ul>


<h3>atomic, nonatomic</h3>

<ul>
<li>atomic: 线程安全，为 setter 加锁，默认就是 atomic，需要消耗大量的资源</li>
<li>nonatomic: 非线程安全，不会为 setter 加锁，适合内存小的移动设备</li>
</ul>


<h3>retain</h3>

<p>自动生成 set 方法内存管理的代码</p>

<ul>
<li>指针的拷贝，使用的是原来的内存空间，对象的索引计数加1</li>
<li>此属性只能用于Objective-C对象类型，而不能用于Core Foundation对象。

<ul>
<li>原因很明显，retain会增加对象的引用计数，而基本数据类型或者 Core Foundation 对象都没有引用计数</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">- (void)setBook:(Book *)book {
    if (_book != book) {
        [_book release];
        _book = [book retain];
    }
}
</code></pre>

<h3>assign</h3>

<p>不会生成 set 方法内存管理的代码，仅仅只会生成普通的 set 方法</p>

<ul>
<li>直接赋值，索引计数不改变，适用于简单数据类型，例如：NSIngeter、CGFloat、int、char 等</li>
<li>修饰对象了类型时，不改变其引用计数</li>
<li>所指对象在被释放之后，仍指向那块内存地址，会产生悬垂指针</li>
</ul>


<pre><code class="objectivec">- (void)setBook:(Book *)book {
    _book = book;
}
</code></pre>

<h3>weak, strong</h3>

<ul>
<li>weak:

<ul>
<li>不改变被修饰对象的引用计数</li>
<li>所指对象在被释放之后会自动置为 nil</li>
<li><code>assign 和 weak 的区别</code>:

<ol>
<li><code>weak / __weak</code>: 弱指针，不会让引用计数器加一，如果指向的对象被销毁，指针会自动清空</li>
<li><code>assign / __unsafe_unretained</code>: 不会让引用计数器加一，如果指向的对象被销毁，指针不会清空</li>
</ol>
</li>
</ul>
</li>
<li>strong: 强指针 <code>__strong</code></li>
</ul>


<h3>copy</h3>

<p>对象的拷贝，新申请一块内存空间，并把原始内容复制到那片空间，新对象的索引计数为 1</p>

<ul>
<li>对象进行拷贝，对于不可变对象拷贝为不可变对象会创建新对象</li>
<li>此属性只对那些实行了 NSCopying 协议的对象类型有效</li>
<li>很多 Objective-C 中的 object 最好使用用 retain，一些特别的 object（例如：string）使用 copy</li>
<li>详见内存管理笔记</li>
<li>会先判断这个对象是可变的还是不可变的

<ul>
<li>所以如该对象不可变可使用 strong，避免判断，以提高性能</li>
</ul>
</li>
<li><strong>一般就用于 NSString 和 block</strong></li>
</ul>


<table>
<thead>
<tr>
<th> 源对象类型 </th>
<th> 拷贝方式 </th>
<th> 目标对象类型 </th>
<th> 拷贝类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td> mutable 对象 </td>
<td> copy </td>
<td> 不可变 </td>
<td> 深拷贝 </td>
</tr>
<tr>
<td> mutable 对象 mutableCopy </td>
<td> 可变 </td>
<td> 深拷贝 </td>
<td></td>
</tr>
<tr>
<td> immutable 对象 </td>
<td> copy </td>
<td> 不可变 </td>
<td> 浅拷贝 </td>
</tr>
<tr>
<td> immutable 对象 </td>
<td> mutableCopy </td>
<td> 可变 </td>
<td> 深拷贝 </td>
</tr>
</tbody>
</table>


<pre><code class="objectivec">@property(copy) NSMutableArray* arr;
// 赋值过来的是 NSMutableArray，copy 之后是 NSArray
// 赋值过来的是 NSArray，copy 之后是 NSArray
// 所以这样定义容易出现一些异常
</code></pre>

<h1><h2 id="synthesize">Synthesize</h2></h1>

<ul>
<li>@synthesize 是一个编译器指令</li>
<li>通常使用 @property 生成了 getter/setter

<ul>
<li>可用 synthesize 来修改属性的名称</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">@interface Person : NSObject
@property int age;
// 相当于下面的代码
/*
{
    int _age;
}
- (void)setAge:(int)age;
- (int)age;

// 并且还在 implementation 中生成了对应的实现
- (void)setAge:(int)age {
    _age = age;
}
- (int)age {
    return _age;
}
*/
@end

@implementation Person

// 告诉编译器，需要实现哪个 @property 生成的声明
//   这里需要实现的是 age property
// 告诉 @synthesize，需要将传入的值赋给谁和返回谁的值给调用者
// 如只写 @synthesize age 那么相当于 @synthesize age = age
// 
@synthesize age = _age;
// 相当于下面的代码
/*
- (void)setAge:(int)age {
    _age = age;
}
- (int)age {
    return _age;
}
*/

@synthesize age = $age;
// 相当于下面的代码
/*
- (void)setAge:(int)age {
    $age = age;
}
- (int)age {
    return $age;
}
*/
@end
</code></pre>

<h2>使用场景</h2>

<pre><code class="objectivec">// 生成了实例变量 _age，并且实现了它的 getter/setter 的声明和实现
@property (nonatomic, assign) int age;

// 当同时重写了 setter/getter 时，系统会报错，原因是找不到 _age 这个变量

// 解决方法一 (在 .h 的文件中声明这个属性)
@interface Person : NSObject {
  int _age;
}
@end;


// 解决方法二 (在 .m 的文件中使用 @synthesize)
@implementation Person

@synthesize age = _age;
// 由于自己重写了 setter/getter 所以得定义下 synthesize
- (int)age {
    return _age;
}
- (void)setAge:(int)age {
    _age = age;
}

@end

/**
@synthesize age = _age 告诉编译器有个叫 _age 的实例变量，它是方法 age 以及 setAge 的实例变量，如果它不存在，就要将它创建出来

通过这个看似像是赋值的一个操作
我们可以在 @synthesize 中定义与变量名不同的 setter 和 getter 的命名
以此来保护变量不会被不恰当的访问
*/
</code></pre>
]]></content>
  </entry>
  
</feed>
