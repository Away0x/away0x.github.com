<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objectivec | Away0x's Blog]]></title>
  <link href="http://away0x.github.io/blog/categories/objectivec/atom.xml" rel="self"/>
  <link href="http://away0x.github.io/"/>
  <updated>2021-04-27T09:36:14+08:00</updated>
  <id>http://away0x.github.io/</id>
  <author>
    <name><![CDATA[TongWu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ObjectiveC - Typedef, Generic, Enum, @class]]></title>
    <link href="http://away0x.github.io/blog/2018/02/11/oc-typedef-generic-enum-class/"/>
    <updated>2018-02-11T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2018/02/11/oc-typedef-generic-enum-class</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#typedef">typedef</a></li>
<li><a href="#generic">generic</a></li>
<li><a href="#enum">enum</a></li>
<li><a href="#class">@class</a></li>
</ul>


<h1><h2 id="typedef">typedef</h2></h1>

<pre><code class="objectivec">// 未使用别名
enum IColor {
    kIColorBlack,
    kIColorWhite
}

@interface Iphone : NSObject {
    enum IColor _color; // 类型名很长
}

@end

@implementation Iphone

@end

// 使用别名
typedef enum {
    kIColorBlack,
    kIColorWhite
} IColor;

@interface Iphone : NSObject {
    IColor _color; // 使用类型别名
}

@end

@implementation Iphone

@end

// 使用
int main(int argc, const char * argv[]) {
    Iphone *p = [Iphone new];
    p-&gt;_color = kIColorBlack;

    return 0;
}
</code></pre>

<h1><h2 id="generic">generic</h2></h1>

<blockquote><p>iOS9+</p></blockquote>

<ol>
<li>用于限制类型</li>
<li>提高代码规划，减少沟通成本</li>
<li>限制集合里的存储类型，不限制的话都是 id 类型

<ul>
<li>限制后只能存储对应类型，且由于有了具体类型，取出时可以使用点语法</li>
<li>id 类型是不能使用点语法的</li>
</ul>
</li>
<li>泛型仅仅是报警告</li>
</ol>


<pre><code class="objectivec">// 不用泛型 --------
// 属性
@property (nonatomic, strong) NSMutableArray *arr;

// 使用
[_arr addObject:@"112"]; // 由于定义时没用泛型，所以这里 add 进去的其实是 id 类型
_arr[0].length; // 报错，_arr[0] 里面是 id 类型，id 类型不能使用点语法

// 使用泛型 --------
// 属性
@property (nonatomic, strong) NSMutableArray&lt;NSString *&gt; *arr;

// 使用
[_arr addObject:@"112"]; // add 的是 NSString 类型
_arr[0].length; // 不报错，数组里是 NSString 类型
</code></pre>

<pre><code class="objectivec">// 参数
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
</code></pre>

<pre><code class="objectivec">// 限定类型
@interface Test&lt;ObjectType&gt; : NSObject
@property (nonatomic, strong) ObjectType language;
@end

// 使用
Java *java = [[Java alloc] init];
iOS *ios = [[iOS alloc] init];

Test&lt;iOS *&gt; *t = [[Test alloc] init];
t.language = ios;  // 泛型限制了，这里只能设置 iOS 类型
t.language = java; // 报警告
</code></pre>

<h1><h2 id="enum">enum</h2></h1>

<pre><code class="objectivec">// 第一种写法 (无法设置枚举值类型)
typedef enum {
    DemoTypeTop,
    DemoTypeBottom,
} DemoType;

// 第二种写法 (可设置枚举值类型)
typedef NS_ENUM(NSInteger, DemoType) {
    DemoTypeTop,
    DemoTypeBottom,
};

// 第三种写法 (位移枚举)
// 更强大，使用时可用并运算
typedef NS_OPTIONS(NSInteger, DemoType) {
    DemoTypeTop = 1 &lt;&lt; 0,    // 1*2^0 = 1
    DemoTypeBottom = 1 &lt;&lt; 1, // 1*2^1 = 2
    DemoTypeLeft = 1 &lt;&lt; 2,   // 1*2^2 = 4
    DemoTypeRight = 1 &lt;&lt; 3,  // 1*2^3 = 8
};
</code></pre>

<p>位移枚举可进行位运算</p>

<pre><code class="objectivec">// 按位与 &amp;
//    1&amp;1==1 1&amp;0==0 0&amp;0==0
//    总结: 只有有 0 则为 0
// 按位或 |
//    1|1==1 1|0==1 0|0==0
//    总结: 只有有 1 则为 1

- (void)demo:(DemoType)type {
    if (type &amp; DemoTypeTop) {
        NSLog(@"top --- %zd", type &amp; DemoTypeTop);
    }
    if (type &amp; DemoTypeBottom) {
        NSLog(@"bottom --- %zd", type &amp; DemoTypeBottom);
    }
    if (type &amp; DemoTypeLeft) {
        NSLog(@"left --- %zd", type &amp; DemoTypeLeft);
    }
    if (type &amp; DemoTypeRight) {
        NSLog(@"right --- %zd", type &amp; DemoTypeRight);
    }
}

- (void)test {
    [self demo:DemoTypeTop | DemoTypeRight]; // 打印 top 和 right
    [self demo:0]; // 什么都不会打印

    // 小技巧
    // 如是位移枚举，可观察第一个枚举值，如该枚举值不为 0
    // 那么可默认传 0 做参数，如传 0，那么效率最高 (因为什么额外操作都不会做)
}
</code></pre>

<h2>枚举中的位运算</h2>

<ul>
<li>位移枚举，可以使用并运算 <code>|</code></li>
<li>一般情况下，如方法参数是枚举值，那么可用过 <code>|</code> 符号，连接多个枚举值</li>
</ul>


<pre><code class="objectivec">NSDate *now = [NSDate date];
NSCalendar *calendar = [NSCalendar currentCalendar];

// 分别获取 年月日时分秒
// 如方法参数是位移枚举，那么可用过 | 符号，连接多个枚举值
NSCalendarUnit type = NSCalendarUnitYear |
                      NSCalendarUnitMonth |
                      NSCalendarUnitDay |
                      NSCalendarUnitHour |
                      NSCalendarUnitMinute |
                      NSCalendarUnitSecond;
NSDateComponents *cmps = [calendar components:type fromDate:now];
NSLog(@"year = %ld", cmps.year);
NSLog(@"month = %ld", cmps.month);
NSLog(@"day = %ld", cmps.day);
NSLog(@"hour = %ld", cmps.hour);
NSLog(@"minute = %ld", cmps.minute);
NSLog(@"second = %ld", cmps.second);
</code></pre>

<h1><h2 id="class">@class</h2></h1>

<p>作用: 可以简单的引用一个类</p>

<ul>
<li><p>简单使用: <code>@class Dog;</code> 仅仅是告诉编译器: Dog 是一个类，并不会包含 Dog 这个类的所有内容</p></li>
<li><p><code>@class:</code> 在 <code>.h</code> 文件中使用 <code>@class</code> 引用一个类</p>

<ul>
<li>仅仅只是告诉编译器，<code>@class</code>后面的名称是一个类，不会做任何拷贝操作</li>
<li>注意: 编译器不会知道这个类中有哪些属性和方法，所以在 <code>.m</code> 中使用这个类时，需要 import 这个类，才能使用</li>
</ul>
</li>
<li><code>#import:</code>在 <code>.m</code> 文件中使用 <code>#import</code> 包含这个类的 <code>.h</code> 文件

<ul>
<li>会将整个文件的代码拷贝到 import 所在的位置</li>
<li>只要 import 的文件发生了改变，那么 import 就会重新拷贝一次 (更新操作)

<ul>
<li>多个类时，编译效率变慢</li>
</ul>
</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">// Person2.h 中
@class Person1; // 该文件中引入 Person1 类

// Person2.m 中
#import "Person1.h"
</code></pre>

<p>如果在 A 类中要包含 B类，B 类中又要包含 A 类，则 <code>.h</code> 中一定要用 <code>@class</code> 避免循环引入</p>

<ul>
<li>总结:

<ol>
<li>在 <code>.h</code> 中使用 <code>@class</code> 引用一个类</li>
<li>在 <code>.m</code> 文件中使用 <code>#import</code> 包含这个类的 <code>.h</code> 文件</li>
</ol>
</li>
</ul>


<h2>@class 其他应用场景</h2>

<p>对于循环依赖关系来说，比方 A 类引用 B 类，同时 B 类也引用 A 类</p>

<pre><code class="objectivec">// 这种嵌套包含的代码编译会报错
#import "B.h"
@interface A : NSObject {
    B *_b;
}
@end

#import "A.h"
@interface B : NSObject {
    A *_a;
}
@end
</code></pre>

<pre><code class="objectivec">// 当使用 @class 在两个类相互声明，就不会出现编译报错

@class B
@interface A : NSObject {
    B *_b;
}
@end

@class A
@interface B : NSObject {
    A *_a;
}
@end
</code></pre>

<h2>@class 和 #import 的区别</h2>

<ul>
<li>作用上的区别

<ul>
<li>import 会包含引用类的所有信息(内容)，包括引用类的变量和方法</li>
<li>@class 仅仅是告诉编译器有这么个类，具体这个类有什么信息，完全不知</li>
</ul>
</li>
<li>效率上的区别

<ul>
<li>如果有上百个头文件都 <code>#import</code> 了同一个文件，或者这些文件依次被 <code>#import</code>，那么一旦最开始的头文件有所改动，后面引用到这个文件的所有类都需要重新编译一遍，编译效率非常低</li>
<li>相对来讲，使用 <code>@class</code> 就不会出现这个问题了</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectiveC - Const, Static, Extern]]></title>
    <link href="http://away0x.github.io/blog/2018/02/10/oc-const-static-extern/"/>
    <updated>2018-02-10T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2018/02/10/oc-const-static-extern</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#const">const</a></li>
<li><a href="#static">static</a></li>
<li><a href="#extern">extern</a></li>
</ul>


<h1><h2 id="const">const</h2></h1>

<blockquote><p>苹果推荐使用 const 常量替代宏字符串常量</p></blockquote>

<h2>const 与宏的区别</h2>

<ol>
<li><strong>编译时刻:</strong> 宏是<strong>预编译</strong>(编译之前处理)，const 是<strong>编译阶段</strong></li>
<li><strong>编译检查:</strong> 宏不做检查，不会报编译错误，只是替换，const 会编译检查，会报编译错误</li>
<li><strong>宏的好处:</strong> 宏能定义一些函数、方法。const 则不能</li>
<li><strong>宏的坏处:</strong> 使用大量宏，容易造成编译时间久，每次都需要重新替换</li>
</ol>


<pre><code class="objectivec">// 宏
#define MyAccount @"account"
#define MyUserDefault [NSUserDefaults standardUserDefaults]

// 字符串常量
static NSString * const account = @"account";

- (void)viewDidLoad {
    [super viewDidLoad];

    // 使用宏
    [MyUserDefault setValue:@"123", forKey:MyAccount];

    // 使用 const 常量
    [[NSUserDefaults standardUserDefaults] setValue:@"123", forKey:account];
}
</code></pre>

<h2>使用</h2>

<ul>
<li>作用

<ol>
<li>修饰右边的基本变量或指针变量</li>
<li>被 cosnt 修饰的变量是只读的</li>
</ol>
</li>
<li>使用场景

<ol>
<li>修饰全局只读变量</li>
<li>修饰方法中只读参数</li>
</ol>
</li>
</ul>


<pre><code class="objectivec">int a = 3;
a = 5; // 可以修改

int const b = 3; // 也可这样写 const int b = 3;
b = 5; // 不可修改，报错
</code></pre>

<pre><code class="objectivec">// const 修饰指针变量

int a = 3;
int *p = &amp;a;
NSLog(@"%d", a); // 3
a = 5;
NSLog(@"%d", a); // 5
*p = 8;
NSLog(@"%d", a); // 8

// const 修饰 *p
int a = 3;
int b = 5;
int const *p = &amp;a;
p = &amp;b; // p 可以修改
*p = 8; // *p 被 const 修饰了，不可修改，会报错

// const 修饰 p
int a = 3;
int b = 5;
int * const p = &amp;a;
p = &amp;b; // p 被 const 修饰了，不可修改，会报错
*p = 8; // *p 可被修改
</code></pre>

<pre><code class="objectivec">int * const p;       // p: 不可修改，*p: 可修改
int const *p;        // p: 可修改，  *p: 不可修改
const int * p;       // p: 可修改，  *p: 不可修改
const int * const p; // p: 不可修改，*p: 不可修改
int const * const p; // p: 不可修改，*p: 不可修改
</code></pre>

<h1><h2 id="static">static</h2></h1>

<ol>
<li>修饰局部变量，被其修饰的局部变量，会延长生命周期，生命长度跟整个应用程序有关

<ul>
<li>被 static 修饰的局部变量，只会分配一次内存</li>
<li>被 static 修饰的局部变量，程序一运行就会给其分配内存</li>
</ul>
</li>
<li>修饰全局变量，被 static 修饰的全局变量，作用域会修改，只能在当前文件下使用</li>
</ol>


<h2>static 和 const 联合使用</h2>

<ul>
<li>cosnt 修饰全局变量，使其只读</li>
<li>static 修饰全局变量，使其作用域为文件作用域</li>
</ul>


<pre><code class="objectivec">// 只在当前文件中可访问到的只读全局变量
static NSString * const name = @"wt";

@implementation ViewController
@end
</code></pre>

<h1><h2 id="extern">extern</h2></h1>

<ol>
<li>用于声明(使用)外部全局变量，<strong>注意: 其只能用于声明，不能用于定义</strong></li>
<li>工作原理: 先会去当前文件下查找有无对应全局变量，如没有，才会去其他文件查找</li>
<li>全局变量在程序运行时就会分配，如 A 文件中定义了全局变量 <code>int a = 0</code>，在 B 文件中可用 <code>extern int a</code> 来使用它</li>
<li>如该全局变量使用 static 修饰，那么 extern 无法找到它，因为其是文件作用域</li>
</ol>


<h2>extern 和 const 联合使用</h2>

<pre><code class="objectivec">// A 类
NSString * const a = @"a";

@implementation A
@end
</code></pre>

<pre><code class="objectivec">// 使用全局变量 a
extern NSString *a;

@implementation B

- (void)test {
    NSLog(@"%@", a); // "a" 可读到
    a = @"aa";       // 报错，a 被 const 修饰了，不可修改
}

@end
</code></pre>

<h2>注意点</h2>

<ul>
<li>注意: 全局变量不能定义在自己的类中

<ul>
<li>如多个文件声明了同名的全局变量，会编译失败</li>
</ul>
</li>
<li>可自己创建一个管理全局变量的类，如 <code>GlobeConst</code>

<ul>
<li>在 m 文件中定义全局变量，在 h 中使用 extern 引用，这样其他文件要使用这些全局变量，只要引用 <code>GlobeConst.h</code> 文件即可</li>
<li><code>GlobeConst</code> 中的全局变量使用 const 修饰，避免其他文件使用时对其修改了</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">// GlobeConst.h

extern NSString * const one_name;
</code></pre>

<pre><code class="objectivec">// GlobeConst.m

NSString * const one_name = @"one name";
</code></pre>

<pre><code class="objectivec">// 其他文件

#import "GlobeConst.h"

NSLog(@"%@", one_name); // "one name"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectiveC - Property, Synthesize]]></title>
    <link href="http://away0x.github.io/blog/2018/02/09/oc-property-synthesize/"/>
    <updated>2018-02-09T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2018/02/09/oc-property-synthesize</id>
    <content type="html"><![CDATA[<!-- more -->


<blockquote><p>Xcode4.4之前 @property 用于生成实例变量 getter/setter 的声明，@synthesize 用于生成 getter/setter 的实现</p>

<p>@property 和 @synthesize 在 Xcode4.4 以前一直都是配合着使用，在 4.4 以后，@property 得到了增强，一行代码编译器就会自动帮我们生成 setter 和  getter 方法的声明和实现，同时在 m 文件中声明一个和属性名一样并且在最前面带有下划线的实例变量 (私有的)</p></blockquote>

<ul>
<li><a href="#property">Property</a></li>
<li><a href="#synthesize">Synthesize</a></li>
</ul>


<h1><h2 id="property">Property</h2></h1>

<ul>
<li>@property 是一个编译器指令</li>
<li>可以使用 @property 来代替 getter/setter 方法的声明和实现

<ul>
<li>即只要写 @property 就不用写 getter/setter 方法了</li>
<li>但 @property 生成的 getter/setter 十分简单，想增强，可自己重写</li>
<li>但如<strong>同时重写(只重写其一不会)</strong>了 getter/setter @property 就不会自动生成私有的实例变量</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">// 使用实例变量 getter/setter
@interface Person : NSObject {
    int _age;
}
// setter
- (void)setAge:(int)age;
// getter
- (int)age;
@end
</code></pre>

<pre><code class="objectivec">// 使用 property 替代 实例变量 getter/setter
@interface Person : NSObject

// 编译器只要看到 property，就做下面的事情
//    - 编译时生成一个实例变量 _age
//    - 生成 getter/setter 的声明
//    - 生成 getter/setter 的实现
@property int age; // property 名不用写下划线

@end

// 使用
Person *p = [Person new];
[p setAge:11]; // 可使用 setter 了
p.age = 11;
</code></pre>

<h2>Property 修饰符</h2>

<ul>
<li><code>@property (修饰符1, 修饰符2, ...) 数据类型 变量名;</code></li>
<li>不写修饰符默认为 <code>(atomic, assign, readwrite)</code></li>
</ul>


<h3>readwrite, readonly</h3>

<ul>
<li>readwrite: (默认) 可读可写，生成 getter/setter</li>
<li>readonly: 只读，只生成 getter</li>
<li>也可指定生成的方法的名称</li>
</ul>


<pre><code class="objectivec">@property (readonly) int age;

@property (getter=isMarried) BOOL married;
// 通常 BOOL 类型的属性的 getter 要以 is 开头
</code></pre>

<h3>getter, setter</h3>

<ul>
<li>getter: 可以给生成的 getter 方法起一个名称</li>
<li>setter: 可以给生成的 setter 方法起一个名称</li>
</ul>


<h3>atomic, nonatomic</h3>

<ul>
<li>atomic: 线程安全，为 setter 加锁，默认就是 atomic，需要消耗大量的资源</li>
<li>nonatomic: 非线程安全，不会为 setter 加锁，适合内存小的移动设备</li>
</ul>


<h3>retain</h3>

<p>自动生成 set 方法内存管理的代码</p>

<ul>
<li>指针的拷贝，使用的是原来的内存空间，对象的索引计数加1</li>
<li>此属性只能用于Objective-C对象类型，而不能用于Core Foundation对象。

<ul>
<li>原因很明显，retain会增加对象的引用计数，而基本数据类型或者 Core Foundation 对象都没有引用计数</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">- (void)setBook:(Book *)book {
    if (_book != book) {
        [_book release];
        _book = [book retain];
    }
}
</code></pre>

<h3>assign</h3>

<p>不会生成 set 方法内存管理的代码，仅仅只会生成普通的 set 方法</p>

<ul>
<li>直接赋值，索引计数不改变，适用于简单数据类型，例如：NSIngeter、CGFloat、int、char 等</li>
<li>修饰对象了类型时，不改变其引用计数</li>
<li>所指对象在被释放之后，仍指向那块内存地址，会产生悬垂指针</li>
</ul>


<pre><code class="objectivec">- (void)setBook:(Book *)book {
    _book = book;
}
</code></pre>

<h3>weak, strong</h3>

<ul>
<li>weak:

<ul>
<li>不改变被修饰对象的引用计数</li>
<li>所指对象在被释放之后会自动置为 nil</li>
<li><code>assign 和 weak 的区别</code>:

<ol>
<li><code>weak / __weak</code>: 弱指针，不会让引用计数器加一，如果指向的对象被销毁，指针会自动清空</li>
<li><code>assign / __unsafe_unretained</code>: 不会让引用计数器加一，如果指向的对象被销毁，指针不会清空</li>
</ol>
</li>
</ul>
</li>
<li>strong: 强指针 <code>__strong</code></li>
</ul>


<h3>copy</h3>

<p>对象的拷贝，新申请一块内存空间，并把原始内容复制到那片空间，新对象的索引计数为 1</p>

<ul>
<li>对象进行拷贝，对于不可变对象拷贝为不可变对象会创建新对象</li>
<li>此属性只对那些实行了 NSCopying 协议的对象类型有效</li>
<li>很多 Objective-C 中的 object 最好使用用 retain，一些特别的 object（例如：string）使用 copy</li>
<li>详见内存管理笔记</li>
<li>会先判断这个对象是可变的还是不可变的

<ul>
<li>所以如该对象不可变可使用 strong，避免判断，以提高性能</li>
</ul>
</li>
<li><strong>一般就用于 NSString 和 block</strong></li>
</ul>


<table>
<thead>
<tr>
<th> 源对象类型 </th>
<th> 拷贝方式 </th>
<th> 目标对象类型 </th>
<th> 拷贝类型 </th>
</tr>
</thead>
<tbody>
<tr>
<td> mutable 对象 </td>
<td> copy </td>
<td> 不可变 </td>
<td> 深拷贝 </td>
</tr>
<tr>
<td> mutable 对象 mutableCopy </td>
<td> 可变 </td>
<td> 深拷贝 </td>
<td></td>
</tr>
<tr>
<td> immutable 对象 </td>
<td> copy </td>
<td> 不可变 </td>
<td> 浅拷贝 </td>
</tr>
<tr>
<td> immutable 对象 </td>
<td> mutableCopy </td>
<td> 可变 </td>
<td> 深拷贝 </td>
</tr>
</tbody>
</table>


<pre><code class="objectivec">@property(copy) NSMutableArray* arr;
// 赋值过来的是 NSMutableArray，copy 之后是 NSArray
// 赋值过来的是 NSArray，copy 之后是 NSArray
// 所以这样定义容易出现一些异常
</code></pre>

<h1><h2 id="synthesize">Synthesize</h2></h1>

<ul>
<li>@synthesize 是一个编译器指令</li>
<li>通常使用 @property 生成了 getter/setter

<ul>
<li>可用 synthesize 来修改属性的名称</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">@interface Person : NSObject
@property int age;
// 相当于下面的代码
/*
{
    int _age;
}
- (void)setAge:(int)age;
- (int)age;

// 并且还在 implementation 中生成了对应的实现
- (void)setAge:(int)age {
    _age = age;
}
- (int)age {
    return _age;
}
*/
@end

@implementation Person

// 告诉编译器，需要实现哪个 @property 生成的声明
//   这里需要实现的是 age property
// 告诉 @synthesize，需要将传入的值赋给谁和返回谁的值给调用者
// 如只写 @synthesize age 那么相当于 @synthesize age = age
// 
@synthesize age = _age;
// 相当于下面的代码
/*
- (void)setAge:(int)age {
    _age = age;
}
- (int)age {
    return _age;
}
*/

@synthesize age = $age;
// 相当于下面的代码
/*
- (void)setAge:(int)age {
    $age = age;
}
- (int)age {
    return $age;
}
*/
@end
</code></pre>

<h2>使用场景</h2>

<pre><code class="objectivec">// 生成了实例变量 _age，并且实现了它的 getter/setter 的声明和实现
@property (nonatomic, assign) int age;

// 当同时重写了 setter/getter 时，系统会报错，原因是找不到 _age 这个变量

// 解决方法一 (在 .h 的文件中声明这个属性)
@interface Person : NSObject {
  int _age;
}
@end;


// 解决方法二 (在 .m 的文件中使用 @synthesize)
@implementation Person

@synthesize age = _age;
// 由于自己重写了 setter/getter 所以得定义下 synthesize
- (int)age {
    return _age;
}
- (void)setAge:(int)age {
    _age = age;
}

@end

/**
@synthesize age = _age 告诉编译器有个叫 _age 的实例变量，它是方法 age 以及 setAge 的实例变量，如果它不存在，就要将它创建出来

通过这个看似像是赋值的一个操作
我们可以在 @synthesize 中定义与变量名不同的 setter 和 getter 的命名
以此来保护变量不会被不恰当的访问
*/
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectiveC - Description, Category, Extention]]></title>
    <link href="http://away0x.github.io/blog/2018/02/08/oc-description-category-extention/"/>
    <updated>2018-02-08T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2018/02/08/oc-description-category-extention</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#description">Description</a></li>
<li><a href="#category">Category</a></li>
<li><a href="#extention">Extention</a></li>
</ul>


<h1><h2 id="description">Description</h2></h1>

<pre><code class="objectivec">// 这会调用 A 的 description 方法来输出 A 的描述信息
NSLog(@"%@", A);
</code></pre>

<ul>
<li>description 方法默认返回对象的描述信息 (默认实现是返回类名和对象的内存地址)</li>
<li>description 方法是基类 NSObject 所带的方法，我们可以重写其来输出对象的信息</li>
<li>注意:

<ol>
<li>description 中尽量不要使用 self 来打印</li>
</ol>
</li>
</ul>


<pre><code class="objectivec">- (void)description {
    // 打印 self 应用 %p
    NSLog(@"%p", self); // 这样才行
    // NSLog(@"%@", self); // 使用 %@ 打印 self 会造成死循环
}
</code></pre>

<pre><code class="objectivec">@interface Demo : NSObject

@end

@impletation Demo

- (NSString *)description {
    return [NSString stringWithFormat:@"对象信息"];
}

+ (NSString *)description {
    return [NSString stringWithFormat:@"类对象信息 %@", [Demo class]];
}

@end
</code></pre>

<h1><h2 id="category">Category</h2></h1>

<ul>
<li>Category 是 OC 特有的语法</li>
<li>Category 也分为声明和实现</li>
<li>一个类可有多个 Category</li>
<li>作用

<ol>
<li><strong>可以在不修改原来类的基础上，为这个类扩充一些方法</strong></li>
<li><strong>一个庞大的类可以分模块开发</strong> (把一个类拆分，归类管理)</li>
<li>一个庞大的类可以由多个人来编写，更有利于团队合作</li>
</ol>
</li>
<li>注意事项

<ol>
<li>Category 是用于给原有的类添加方法的，只能添加方法，不能添加实例变量</li>
<li>Category 中添加 @property，只会生成 setter/getter 的声明，不会生成实现和私有实例变量</li>
<li>可以在 Category 中访问原有类 <strong>h 文件</strong>中定义的属性</li>
<li>Category 中有和原有类同名的方法，会覆盖原有类的方法</li>
<li>如多个 Category 中都有和原有类同名的方法，那么调用该方法时由编译器决定执行哪个，会执行最后一个参与编译的分类中的方法</li>
</ol>
</li>
<li>方法的调用顺序

<ol>
<li>分类 > 本类 > 父类 > &hellip; > NSObject</li>
</ol>
</li>
<li>Category 中重写的是原来就有的方法，那么使用其的文件中，不用引入 Category 头文件，就可使用</li>
<li>Category 中重写的是新方法，那么使用其的文件中，需要引入 Category 头文件，方可使用</li>
</ul>


<pre><code class="objectivec">// 例如扩充 Person 类

// Category 声明
// Person+Test.h
@interface Person (Test)

- (void)run;

@end

// Category 实现
// Person+Test.m
@implementation Person (Test)

- (void)run {
    NSLog(@"run...");
}

@end

// 使用 Person 类的地方，只要导入了 Person+Test.h
// 就可以使用 Person 新增的实例方法 run 了
</code></pre>

<h1><h2 id="extention">Extention</h2></h1>

<ul>
<li>Class Extention: 类扩展、匿名 Category</li>
<li>可以为某个类扩充一些<strong>私有</strong>的实例变量和方法，外部是无法访问的

<ul>
<li>保证封装性 (iOS UI 编写中常用)</li>
<li>子类无法获取父类的类扩展</li>
</ul>
</li>
<li>对比 Category

<ol>
<li>写在<strong>m 文件</strong>中</li>
<li>不仅可扩充方法，还可扩充实例变量和 @property</li>
<li>定义格式中不用写分类名</li>
</ol>
</li>
</ul>


<pre><code class="objectivec">// Person.m

// Class Extention
@interface Person ()

@end

// 类的实现
@inpelmentation Person

@end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectiveC - Protocol]]></title>
    <link href="http://away0x.github.io/blog/2018/02/07/oc-protocol/"/>
    <updated>2018-02-07T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2018/02/07/oc-protocol</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#o1">基础</a></li>
<li><a href="#o2">使用场景</a></li>
</ul>


<h1><h2 id="o1">基础</h2></h1>

<ul>
<li>Java 中有 interface 接口。而 OC 中 interface 是类的头文件声明，OC 的接口由 protocol 实现</li>
<li>protocol 可<strong>声明一些必须实现的方法和选择实现的方法</strong></li>
<li>protocol 的作用

<ol>
<li>用来声明一些方法</li>
</ol>
</li>
<li>protocol 是由一系列的方法声明组成的</li>
<li><strong>类遵守 protocol</strong>

<ol>
<li>一个类可以遵守一个或多个 protocol</li>
<li>任何类只要遵守了 protocol，就相当于拥有了 protocol 的所有方法声明</li>
</ol>
</li>
<li><strong>协议和继承的区别</strong>

<ol>
<li>继承后默认就有实现，而协议只有声明没有实现</li>
<li>相同类型的类可以使用继承，但是不同类型的类只能使用协议</li>
<li>协议可用于存储方法的声明，可以将多个类中共同的方法抽取出来，以后让这些类遵守协议即可</li>
</ol>
</li>
<li><strong>协议的注意事项</strong>

<ol>
<li>协议只能声明方法，不能声明属性</li>
<li>父类遵守了某个协议，那么子类也会自动遵守这个协议</li>
<li>OC 中一个类可以遵守一个或多个协议</li>
<li>OC 中的协议可遵守其他协议，只要一个协议遵守了其他协议，那么这个协议中就会自动包含其他协议的声明</li>
</ol>
</li>
</ul>


<h2>定义</h2>

<pre><code class="objectivec">// 定义 protocol
@protocol 协议名称
// 方法声明列表
@end

// 类遵守 protocol
@interface 类名 : 父类 &lt;协议1, 协议2, ...&gt;
@end
</code></pre>

<h2>基协议 NSObject</h2>

<ul>
<li>NSObject 是一个基类，最根本最基本的类，任何其他类都要继承自它</li>
<li>还有个协议也叫 NSObject，它是一个基协议，最根本最基本的协议</li>
<li>NSObject 协议中声明了很多最基本的方法

<ol>
<li>description</li>
<li>retain</li>
<li>release</li>
</ol>
</li>
<li>建议每个新的协议都要遵守 NSObject 基协议</li>
</ul>


<pre><code class="objectivec">@protocol DemoProtocol &lt;NSObject&gt;
@end
</code></pre>

<h2>@required &amp; @optional</h2>

<ul>
<li>@require: (默认) 这个方法必须实现，不实现会有警告，但不会报错</li>
<li>@optional: 这个方法不一定要实现</li>
</ul>


<pre><code class="objectivec">@protocol DemoProtocol &lt;NSObject&gt;
/*
 func0、func1、func2 不实现会有警告
 func3 可以不实现
*/

- (void)func0; // 默认是 required

@required
- (void)func1;
- (void)func2;

@optional
- (void)func3;

@end
</code></pre>

<h1><h2 id="o2">使用场景</h2></h1>

<h2>类型限制</h2>

<ul>
<li>通过协议来限制类型</li>
<li><code>数据类型&lt;协议名称&gt; 变量名</code></li>
</ul>


<pre><code class="objectivec">@protocol Animal &lt;NSObject&gt;
- (void)eat;
- (void)run;
@end

// 如果 dog 没有遵守 Animal 协议就会报警告
Dog&lt;Animal&gt; dog = [[Dog alloc]init];
</code></pre>

<pre><code class="objectivec">@interface Dog : NSObject

// 限制 property 的类型需要遵守 Animal 协议
@property (nonatomic, strong) Puppy&lt;Animal&gt; *puppy1;

// 这个 property 无论是何类都可，但是得遵守 Animal 协议
@property (nonatomic, strong) id&lt;Animal&gt; *son;

@end
</code></pre>

<p><strong>注意:</strong> 虽然在对对象进行了类型限定(限定它必须实现某个协议)，但并不意味着这个对象就真正的实现了该方法(不实现只是由警告无报错)。所以在调用对象的协议方法时，应该进行判断</p>

<pre><code class="objectivec">Dog&lt;Animal&gt; dog = [[Dog alloc]init];

// 判断 dog 是否能响应 eat 消息 (即是否有实现这个方法)
if ([dog respondsToSelector:@selector(eat)]) {
    [dog eat];
}
</code></pre>

<h2>委托代理</h2>

<p>详见类之间通信的笔记</p>
]]></content>
  </entry>
  
</feed>
