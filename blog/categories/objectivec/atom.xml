<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objectivec | Away0x's Blog]]></title>
  <link href="http://away0x.github.io/blog/categories/objectivec/atom.xml" rel="self"/>
  <link href="http://away0x.github.io/"/>
  <updated>2022-05-20T23:11:20+08:00</updated>
  <id>http://away0x.github.io/</id>
  <author>
    <name><![CDATA[TongWu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ObjectiveC - KVO, KVC, Delegate, Notification, Block]]></title>
    <link href="http://away0x.github.io/blog/2018/02/17/oc-kvo-kvc-delegate-notification-block/"/>
    <updated>2018-02-17T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2018/02/17/oc-kvo-kvc-delegate-notification-block</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#kvo">KVO</a></li>
<li><a href="#kvc">KVC</a></li>
<li><a href="#delegate">Delegate</a></li>
<li><a href="#notification">Notification</a>

<ul>
<li><a href="#notification-params">带参数通知</a></li>
<li><a href="#notification-om">一对多通知接收</a></li>
<li><a href="#notification-mo">通知的多对一关系</a></li>
<li><a href="#notification-t">多线程中使用通知</a></li>
<li><a href="#notification-d">系统通知</a></li>
<li><a href="#notification-k">键盘通知</a></li>
</ul>
</li>
<li><a href="#block">Block</a></li>
<li><a href="#diff">通知、KVO、委托代理的区别</a></li>
</ul>


<h1><h2 id="kvo">KVO</h2></h1>

<p>通过 KVC 的方式修改被观察者的属性时，主动通知观察者</p>

<ul>
<li>KVO: 监听对象属性的变化</li>
<li>使用步骤

<ol>
<li>注册</li>
<li>观察</li>
<li>移除观察</li>
</ol>
</li>
<li>KVO 的性能问题

<ul>
<li>如果一个类用 KVO 监听，系统会为其生成一个子类</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">// ---------------- KVOClass ----------------------
@interface KVOClass : NSObject
@property(nonatomic,strong)Person *p1;
-(void)testKVO;
@end

@implementation KVOClass
-(void)testKVO{
// 1 注册
    self.p1 = [[Person alloc]init];
    [self.p1 setAge:15];
    // Observer: 观察者
    // KeyPath: 要监听的属性
    // options: 方法中要拿到的属性值
    [self.p1 addObserver:self
        forKeyPath:@"age"
        options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld
        context:nil];
    [self.p1 setAge:16];
}
// 3 移除
-(void)dealloc{
    [self.p1 removeObserver:self forKeyPath:@"age"];
}
// 2 观察 KVO 的监听方法
-(void)observeValueForKeyPath:(NSString *)keyPath
    ofObject:(id)object
    change:(NSDictionary&lt;NSString *,id&gt; *)change
    context:(void *)context{

    NSLog(@"我的年龄变化了");
    NSLog(@"之前的年龄 %d", [change[NSKeyValueChangeOldKey] intValue]);
    NSLog(@"现在的年龄 %d", [change[NSKeyValueChangeNewKey] intValue]);
}
@end

// ---------------- Person ----------------------
@interface Person : NSObject
@property(nonatomic,assign)int age;
@end

@implementation Person
@end

// ---------------- 执行文件 ----------------------
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        KVOClass *kvo = [[KVOClass alloc]init];
        [kvo testKVO];
    }
    return 0;
}
</code></pre>

<h1><h2 id="kvc">KVC</h2></h1>

<p>简单来说， 是存取类属性， 通过字符串来访问对象属性</p>

<ul>
<li>KVC (Key Value Coding) 键值编码</li>
<li>Java/C# 中可通过反射读取对象的属性</li>
<li>动态设置

<ul>
<li>setValue (属性值) forKey (属性名)</li>
<li>setValue (属性值) forKeyPath (属性路径)</li>
<li>setValuesForKeysWithDictionary</li>
</ul>
</li>
<li>动态读取

<ul>
<li>valueForKey (属性名)</li>
<li>valueForKeyPath (属性名)</li>
<li>dictionaryWithValuesForKeys</li>
</ul>
</li>
<li>KVC 可设置类的私有成员变量</li>
</ul>


<pre><code class="objectivec">// ---------------- Person ----------------------
@interface Person : NSObject
@property(nonatomic,assign) int age;
@property(nonatomic,copy) NSString* name;
@end

@implementation Person
@end

// ---------------- 执行文件 ----------------------
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Person *p1 = [[Person alloc]init];
        [p1 setValue:@"henry" forKeyPath:@"name"]; // 可 forKeyPath:@"a.b"
        [p1 setValue:@"18" forKeyPath:@"age"];
        // 批量设置属性
        //   - p1 必须得有 key 对应的属性才行
        [p1 setValuesForKeysWithDictionary:@{
            @"name": @"wt",
            @"age": @26
        }];

        Person *p2 = [[Person alloc]init];
        [p2 setValue:@"robin" forKeyPath:@"name"];
        [p2 setValue:@"17" forKeyPath:@"age"];

        NSLog(@"p1=%@ p2=%@",p1,[p2 valueForKeyPath:@"name"]);
        // 批量获取值
        NSLog(@"%@", [p1 dictionaryWithValuesForKeys:@[@"name", @"age"]);
    }
    return 0;
}
</code></pre>

<h2>作用</h2>

<ol>
<li>字典转模型 ,简化代码量</li>
<li>修改系统的只读变量: 例如自定义tabBar的时候,由于tabBar是只读属性,只能用KVC赋值</li>
<li>可以任意修改一个对象的属性和变量(包括私有变量)</li>
<li>可以通过运算符层次查找对象的属性</li>
</ol>


<pre><code class="objectivec">keyPathTeacher *t = [Teacher alloc ] init];
t.chiild = [Child alloc ] init];
t.child.book = [Book alloc] init];

NSLog(@"%@",ValueForKeyPath(@"child.book"));
</code></pre>

<h1><h2 id="delegate">Delegate</h2></h1>

<p>委托代理也可通过 block 实现</p>

<ul>
<li>适用场合:

<ol>
<li>当对象 A 发生了一些行为，想告知对象 B (让对象 B 成为对象 A 的代理对象)</li>
<li>对象 B 想监听对象 A 的一些行为(让对象 B 成为对象 A 的代理对象)</li>
<li>当对象 A 无法处理某些行为的时候，想让对象 B 帮忙处理(让对象 B 成为对象 A 的代理对象)</li>
</ol>
</li>
<li>协议规范

<ol>
<li>一般情况下，当前协议属于谁，就将协议定义在谁的头文件上</li>
</ol>
</li>
<li>步骤：

<ol>
<li>定义协议 <code>类名 + Delegate</code> (需遵守 NSObject 基协议)</li>
<li>委托 <code>委托类，需实现上面定义的代理协议</code></li>
<li>代理方法的调用</li>
</ol>
</li>
</ul>


<pre><code class="objectivec">// AClass
// ---------------- 头文件 ----------------------
// 声明协议
@protocol BuyTicketDelegate;

@interface AClass: NSObject
@property(nonatomic, weak) id&lt;BuyTicketDelegate&gt; delegete; // delegete 用于接受委托
- (void)myBuyTicket;
@end

// 1. 定义协议
@protocol BuyTicketDelegate &lt;NSObject&gt;

@optional // 表下面的方法不一定要实现
- (void) buyTicket;

@end

// ---------------- 实现文件 ----------------------
@implementation AClass

- (void)myBuyTicket {
    // 判断代理中是否有要求的方法
    if ([self.delegete respondsToSelector:@selector(buyTicket)]) {
        [self.delegete buyTicket];
    }
}

@end
</code></pre>

<pre><code class="objectivec">// BClass
// ---------------- 头文件 ----------------------
@interface BClass : NSObject&lt;BuyTicketDelegate&gt;
- (void)testDelegate;
@end

// ---------------- 实现文件 ----------------------
@implementation BClass

- (void)testDelegate {
    AClass *classa = [[AClass alloc] init];
    classa.delegete = self; // 设置代理，委托 self
    [classa myBuyTicket];
}
- (void) buyTicket {
    NSLog(@"我是 BClass 中的方法");
}

@end
</code></pre>

<pre><code class="objectivec">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        BClass *classb = [[BClass alloc] init];
        [classb testDelegate]; // 打印 "我是 BClass 中的方法"
    }
}
</code></pre>

<h1><h2 id="notification">Notification</h2></h1>

<ul>
<li>每一个应用程序都有一个通知中心(NSNotificationCenter)实例，专门负责协助不同对象之间的消息通信</li>
<li>任何一个对象都可以向通知中心发布通知(NSNotification)，描述自己在做什么。其他感兴趣的对象(Observer)可以申请在某个特定通知发布时或在某个特定的对象发布通知时，收到这个通知</li>
<li>通知基本原理

<ul>
<li> 角色：通知中心、发起人、接收者</li>
<li> 步骤：

<ol>
<li>接受者向通知中心注册</li>
<li>定义一些通知接收的方法</li>
<li>发起人向通知中心发通知</li>
</ol>
</li>
</ul>
</li>
<li>一个完整的通知需要包含 3 个属性

<ol>
<li><code>- (NSString *)name;</code> (通知的名称)</li>
<li><code>- (id)object;</code> (通知发布者)</li>
<li><code>- (NSDictionary *)userInfo</code> (一些额外的信息，通知发布者传递给通知接受者的信息内容)</li>
</ol>
</li>
<li>监听通知需在发布通知之前</li>
</ul>


<pre><code class="objectivec">// 1. A 对象发布通知
//    - 定义通知对象
//        - object 为 nil 时，为发布匿名通知 (不指定发布者)
NSNotification *note = [NSNotification notificationWithName:@"通知名称"
    object:A userInfo:@{@"title": @"通知内容xxx"}];
//    - 发送
[[NSNotificationCenter defaultCenter]postNotification:note];
/**
* 或者也可 (简化发送的方法)
[[NSNotificationCenter defaultCenter] 
    postNotificationName:@"通知名称"
    object:A
    userInfo:@{@"title": @"通知内容xxx"}];
*/

// 2. B 对象订阅通知
//     - addObserver: 通知接收者
//     - selector: 通知接收到时执行的函数
//         - doAction: 参数为通知对象 note
//     - name: 通知名称，nil 时为接收任何 object 的通知
//     - object: 通知发布者, nil 时为接收任何 name 名的通知
//         - name 和 object 都为 nil 时，为接收任何通知
[[NSNotificationCenter defaultCenter]addObserver:B
    selector:@selector(doAction:)
    name:@"通知名称"
    object:A];

// 3. 通知的移除 (取消订阅)
[[NSNotificationCenter defaultCenter]removeObserver:B
    name:@"通知名称"
    object:A];
// 或
[[NSNotificationCenter defaultCenter]removeObserver:B];
</code></pre>

<pre><code class="objectivec">// AClass
// ---------------- 头文件 ----------------------

// ---------------- 实现文件 ----------------------
@implementation AClass
- (void) init {
    self = [super init];
    if (self) {
        // 3. 发起人向通知中心发送通知
        [[NSNotificationCenter defaultCenter] 
            postNotificationName:@"TESTNOTIF" object:nil];
    }
    return self;
}
@end
</code></pre>

<pre><code class="swift">// BClass
// ---------------- 头文件 ----------------------
@interface BClass : NSObject&lt;BuyTicketDelegate&gt;
- (void)testNotification;
@end
// ---------------- 实现文件 ----------------------
@implementation BClass
- (void)testNotification {
    // 1. 接受者向通知中心注册
    // 参数1：谁在接收这个方法，参数2：响应方法，参数3：通知名称，参数4通知发布者
    // self 指当前的这个类
    [[NSNotificationCenter defaultCenter] 
        addObserver:self selector:@selector(testAction) name:@"TESTNOTIF" object:nil];

    AClass *classa = [[AClass alloc] init]; // A 类的构造方法中发广播
}
// 2. 定义一些通知接收的方法
- (void)testAction {
    NSLog(@"接收到通知了");
}
// 广播销毁的方法
- (void)dealloc {
    [[NSNotificationCenter defaultCenter] removeObserver:self name:@"TESTNOTIF" object:nil];
}
@end
</code></pre>

<pre><code class="swift">// A 类中发送通知，B 类中接收
// main
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        BClass *classb = [[BClass alloc] init];
        [classb testNotification]; // "接收到通知了"
    }
}
</code></pre>

<h2><h3 id="notification-params">带参数通知</h3></h2>

<pre><code class="objectivec">// AClass
// ---------------- 头文件 ----------------------

// ---------------- 实现文件 ----------------------
@implementation AClass
- (void) init {
    self = [super init];
    if (self) {
        // 3. 发起人向通知中心发送通知
        // 如通知需要携带数据，可以：
        NSMutableDictionary *dic = [[NSMutableDictionary alloc] init];
        [dic setValue:@"123" forKey:@"keya"];

        // 参数1：通知名，参数2：object，参数3：dict(字典)
        [[NSNotificationCenter defaultCenter] 
            postNotificationName:@"TESTNOTIF" object:
            [NSNumber numberWithInt:5] userInfo:dic];
    }
    return self;
}
@end
</code></pre>

<pre><code class="objectivec">// BClass
// ---------------- 头文件 ----------------------
@interface BClass : NSObject&lt;BuyTicketDelegate&gt;
- (void)testNotification;
@end
// ---------------- 实现文件 ----------------------
@implementation BClass
- (void)testNotification {
    // 1. 接受者向通知中心注册
    // 参数1：谁在接收这个方法，参数2：响应方法，参数3：通知名称，参数4：通知发布者
    // self 指当前的这个类
    [[NSNotificationCenter defaultCenter] 
        addObserver:self selector:@selector(testAction:) name:@"TESTNOTIF" object:nil];

    AClass *classa = [[AClass alloc] init]; // A 类的构造方法中发通知
}
// 2. 定义一些通知接收的方法(拿到参数)
- (void)testAction:(NSNotification*)notif {
    NSNumber *num = notif.object;
    NSDictionary *dic = notif.userInfo;
    NSLog(@"%@ %@", num, dic);
}
// 通知销毁的方法
- (void)dealloc {
    [[NSNotificationCenter defaultCenter] removeObserver:self name:@"TESTNOTIF" object:nil];
}
@end
</code></pre>

<pre><code class="objectivec">// A 类中发送通知，B 类中接收
// main
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        BClass *classb = [[BClass alloc] init];
        [classb testNotification]; // "接收到广播了"
    }
}
</code></pre>

<h2><h3 id="notification-om">一对多通知接收(一个发送，多个接收)</h3></h2>

<pre><code class="objectivec">// Person 发出通知，Student 和 Teacher 会接收到

// ---------------- Person ----------------------
@interface Person : NSObject
-(void)testNotification;
@end

@interface Person(){
    Student *s1;
    Teacher *t1;
}
@end
@implementation Person
-(void)testNotification{
    // [Student new];
    // [Teacher new]; // 这种方式定义的对象 (通知还未来得及发送，对象就已经被释放掉了)
    s1 = [[Student alloc]init];
    t1 = [[Teacher alloc]init];
    [[NSNotificationCenter defaultCenter]postNotificationName:@"TESTNOTIF" object:nil];
}
@end

// ---------------- Student ----------------------
@implementation Student
-(id)init{
    self = [super init];
    if (self) {
        [[NSNotificationCenter defaultCenter]
            addObserver:self
            selector:@selector(notifAction)
            name:@"TESTNOTIF"
            object:nil];
    }
    return self;
}
-(void)notifAction{
    NSLog(@"student 接收");
}
-(void)dealloc{
    [[NSNotificationCenter defaultCenter]removeObserver:self name:@"TESTNOTIF" object:nil];
}
@end

// ---------------- Teacher ----------------------
@implementation Teacher
-(id)init{
    self = [super init];
    if (self) {
        [[NSNotificationCenter defaultCenter]
            addObserver:self
            selector:@selector(notifAction)
            name:@"TESTNOTIF"
            object:nil];
    }
    return self;
}
-(void)notifAction{
    NSLog(@"teacher 接收");
}
-(void)dealloc{
    [[NSNotificationCenter defaultCenter]removeObserver:self name:@"TESTNOTIF" object:nil];
}
@end

// ---------------- 使用文件 ----------------------
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Person *p1 = [[Person alloc]init];
        [p1 testNotification];
    }
    return 0;
}
</code></pre>

<h2><h3 id="notification-mo">通知的多对一关系(多个发送，一个接收)</h3></h2>

<pre><code class="objectivec">// Student 和 Teacher 发出通知，Person 会接收到

// ---------------- Person ----------------------
@interface Person : NSObject
//@property
-(void)testNotification;
@end

@interface Person(){
    Student *s1;
    Teacher *t1;
}
@end
@implementation Person
-(void)testNotification{

    [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(notifAction:) name:@"TESTNOTIF" object:nil];
    s1 = [[Student alloc]init];
    t1 = [[Teacher alloc]init];
}
-(void)notifAction:(NSNotification*)notif{
    NSDictionary *dic = notif.userInfo;
    NSString *string = [dic valueForKey:@"info"];
    NSLog(@"%@",string);
}
-(void)dealloc{
    [[NSNotificationCenter defaultCenter]removeObserver:self name:@"TESTNOTIF" object:nil];
}
@end

// ---------------- Student ----------------------
@implementation Student
-(id)init{
    self = [super init];
    if (self) {
        NSMutableDictionary *dic = [[NSMutableDictionary alloc]init];
        [dic setValue:@"我来自Student" forKey:@"info"];
        [[NSNotificationCenter defaultCenter]postNotificationName:@"TESTNOTIF" object:nil userInfo:dic];
    }
    return self;
}
@end

// ---------------- Teacher ----------------------
@implementation Teacher
-(id)init{
    self = [super init];
    if (self) {
        NSMutableDictionary *dic = [[NSMutableDictionary alloc]init];
        [dic setValue:@"我来自Teacher" forKey:@"info"];
        [[NSNotificationCenter defaultCenter]postNotificationName:@"TESTNOTIF" object:nil userInfo:dic];
    }
    return self;
}
@end

// ---------------- 使用文件 ----------------------
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Person *p1 = [[Person alloc]init];
        [p1 testNotification];
    }
    return 0;
}
</code></pre>

<h2><h3 id="notification-t">多线程中使用通知</h3></h2>

<pre><code class="objectivec">// 监听通知
// Name: 通知名字
// object: 谁发出的通知
// queue: 决定 block 在哪个线程执行，nil 表示在发布通知的线程中执行
// usingBlock: 只要监听到通知，就会执行这个 block
id observe = [[NSNotificationCenter defaultCenter]
    addObserverFromName:@"note"
    object:nil
    queue:nil
    usingBlock:^(NSNotification * __NONNULL note) {
        // 只要监听到通知，就会调用
        NSLog(@"%@", [NSTread currentThread]);
    }];


// 发出通知
[[NSNotificationCenter defaultCenter]postNotificationName:@"note" object:nil];

// 移除通知
[[NSNotificationCenter defaultCenter]removeObserver:observe];
</code></pre>

<h3>通知在多线程中的注意点</h3>

<ul>
<li>接收通知的代码在哪个线程执行是由发通知的的线程决定的

<ul>
<li>可通过 addObserverFromName 的 queue 参数指定</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">// 异步线程监听通知，主线程发通知

// 监听通知在异步中
dispatch_async(dispatch_get_global_queue(0, 0), ^{
    // 异步任务
    [[NSNotificationCenter defaultCenter]
        addObserver:self
        selector:@selector(reciveNote) // reciveNote 这个方法是在主线程中调用的(因为发通知在主线程)
        name:@"note"
        objeect:nil];
});

// 发出通知
[[NSNotificationCenter defaultCenter]postNotificationName:@"note" object:nil];

// 发现这段代码中的异步任务中监听不到通知
// 这是由于异步任务执行的顺序不确定，有可能监听在发通知之后

// 当发通知的代码改为如点击事件触发，保证一定在监听之后执行，则异步线程中监听通知成功
</code></pre>

<pre><code class="objectivec">// 当发通知在异步线程中，主线程监听通知

// 由于监听到通知触发的回调执行在的线程由发通知的线程决定
// 因此该回调执行在异步线程中
// 如果改回调中需要修改 UI，则需在主线程中修改

// 执行在异步线程，但更新 UI 的代码执行在主线程总
- (void)reciveNote {

    // ....

    // 回到主线程更新 UI
    dispatch_sync(dispatch_get_main_queue(), ^{
        // 修改 UI
    });
}
</code></pre>

<pre><code class="objectivec">// queue 参数指定 block 在指定线程执行
// 无论发通知是在哪个线程中都没关系

id observe = [[NSNotificationCenter defaultCenter]
    addObserverFromName:@"note"
    object:nil
    queue:[NSOperationQueue mainQueue]
    usingBlock:^(NSNotification * __NONNULL note) {
        // 只要监听到通知，就会调用
        NSLog(@"%@", [NSTread currentThread]);
    }];
</code></pre>

<h2><h3 id="notification-d">系统通知 UIDevice</h3></h2>

<ul>
<li>UIDevice 类提供了一个单例对象，它代表着设备，通过它可以获得一些设备相关的信息，比如:

<ul>
<li>电池电量值 batteryLevel</li>
<li>设备类型 model (iPod、iPhone &hellip;)</li>
<li>设备系统 systemVersion</li>
</ul>
</li>
<li>可通过 <code>[UIDevice currentDevice</code> 获取这个单例对象</li>
<li>UIDevice 对象会不间断的发布一些通知，下面是通知名称

<ol>
<li><code>UIDeviceOrientationDidChangeNotification</code> 设备旋转</li>
<li><code>UIDeviceBatteryStateDidChangeNotification</code> 电池状态改变</li>
<li><code>UIDeviceBatteryLevelDidChangeNotification</code> 电池电量改变</li>
<li><code>UIDeviceProximityStateDidChangeNotification</code> 近距离传感器 (比如设备贴近使用者的脸部)</li>
</ol>
</li>
</ul>


<pre><code class="objectivec">// 系统版本
double version [[UIDevice currentDevice].systemVersion.doubleValue;

if (version &gt;= 9.0) {
    // do something   
}
</code></pre>

<h2><h3 id="notification-k">键盘通知</h3></h2>

<p>键盘状态改变时，系统会发出一些特定的通知</p>

<ol>
<li><code>UIKeyboardWillShowNotification</code> 键盘即将显示</li>
<li><code>UIKeyboardDidShowNotification</code> 键盘显示完毕</li>
<li><code>UIKeyboardWillHideNotification</code> 键盘即将隐藏</li>
<li><code>UIKeyboardDidHideNotification</code> 键盘隐藏完毕</li>
<li><code>UIKeyboardWillChangeFrameNotification</code> 键盘的位置尺寸即将发生改变</li>
<li><code>UIKeyboardDidChangeFrameNotification</code> 键盘的位置尺寸改变完毕</li>
</ol>


<h1><h2 id="block">Block</h2></h1>

<ul>
<li>block: 代码块</li>
<li>本质上是函数指针(代码块的内存地址)</li>
<li>常用语传值，即把 block 的地址传到要调用 block 的地方</li>
</ul>


<h2>实现</h2>

<pre><code class="objectivec">// 1. 声明 block (返回值 + Block名 + 传递参数)
typedef int (^MyBlock)(int);

int main(int argc, const char * argv[]) {
    @autoreleasepook {
        int a = 5;
        __block int aa = 5;
        // 2. 实现 block
        MyBlock b1 = ^(int b) {
            NSLog(@"%d", b);
            // block 中使用外部变量，声明时，需加 __block
            return b + 1;
        };
        // 3. 调用 block
        int newb = b1(10); // 11
    }
    return 0;
}
</code></pre>

<h2>类之间的通信为什么要用 block</h2>

<pre><code class="objectivec">@interface AClass : NSObject
- (void)testBlock;
@end

@implementation AClass
- (void)testBlock {
    // A 类中调 B 类的方法
    BClass *classb = [[BClass alloc] init];
    [classb testB]; 
}
@end
</code></pre>

<pre><code class="objectivec">@interface BClass : NSObject
- (void)testB;
@end

@implementation BClass
- (void)testB {
    NSLog(@"我是B");
    // 如果 B 类想使用 A 类的方法，不可实例化 A 类(会交叉引用)，得使用 block
    // AClass *classa = [[AClass alloc] init];
}
@end
</code></pre>

<pre><code class="objectivec">int main(int argc, const char * argv[]) {
    @autoreleasepook {
        AClass *classa = [[AClass alloc] init];
    }
    return 0;
}
</code></pre>

<h2>类之间通信中使用 block</h2>

<p>其实就是 A 传递一个函数给 B，从而实现在 B 中调 A 的方法</p>

<pre><code class="objectivec">@interface AClass : NSObject
- (void)testBlock;
@end

@implementation AClass
- (void)testBlock {
    // 声明 block
    MyBlock b1 = ^(NSString *str1) {
        NSLog(@"AClass:%@", str1);
    };
    // 调用 B 类
    BClass *classb = [[BClass alloc] init];
    [classb testB:b1 str1:@"AClass"];

    // ---------------
    // 快速传递 block(类似 js 的回调)
    BClass *classb = [[BClass alloc] init];
    [classb testB:^(NSString *str1) {
        NSLog(@"AClass:%@", str1);
    } str1:@"AClass"];
}
@end
</code></pre>

<pre><code class="objectivec">typedef void (^MyBlock)(NSString*); // 声明 block
@interface BClass : NSObject
- (void)testB:(MyBlock)block str1:(NSString)str1;
@end

@implementation BClass
- (void)testB:(MyBlock)block str1:(NSString)str1 {
    NSLog(@"%@", str1);
    block(@"我是从B类来的");
}
@end
</code></pre>

<pre><code class="objectivec">int main(int argc, const char * argv[]) {
    @autoreleasepook {
        AClass *classa = [[AClass alloc] init];
    }
    return 0;
}
</code></pre>

<h1><h2 id="diff">通知、KVO、委托代理的区别</h2></h1>

<ul>
<li>三者都是 iOS 中监听事件的方式</li>
<li><strong>通知</strong>

<ul>
<li>任何对象之间都可以传递消息</li>
<li>使用范围

<ol>
<li>1 个对象可以发通知给多个对象</li>
<li>1 个对象可以接受多个对象发出的通知</li>
</ol>
</li>
<li>要求: 必须得保证通知的名字在发出和监听时是一致的</li>
</ul>
</li>
<li><strong>KVO</strong>

<ul>
<li>仅能监听对象属性的变化 (灵活度不如通知和代理)</li>
</ul>
</li>
<li><strong>代理</strong>

<ul>
<li>1 个对象只能设置一个代理 (假设这个对象只有一个代理属性)</li>
<li>1 个对象能成为多个对象的代理</li>
</ul>
</li>
<li>如何选择

<ol>
<li>代理比通知规范</li>
<li>建议使用代理多于通知，能使用代理尽量使用代理</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectiveC - 单例]]></title>
    <link href="http://away0x.github.io/blog/2018/02/16/oc-singleton/"/>
    <updated>2018-02-16T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2018/02/16/oc-singleton</id>
    <content type="html"><![CDATA[<!-- more -->


<p>单例可以保证在程序运行过程，一个类只有一个实例，而且该实例易于供外界访问从而方便地控制了实例个数，并节约系统资源</p>

<p>使用场合: 在整个应用程序中，共享一份资源 (这份资源只需要创建初始化一次)</p>

<ul>
<li><a href="#arc">ARC环境下实现单例模式</a></li>
<li><a href="#mrc">MRC环境下实现单例模式</a></li>
<li><a href="#am">ARC与MRC通用的单例</a></li>
</ul>


<h1><h2 id="arc">ARC 环境下实现单例模式</h2></h1>

<pre><code class="objectivec">// 懒加载的单例的写法

@implementation Demo

// 提供全局变量
static Demo *_instance;

+ (instancetype)allocWithZone:(struct _NSZone *)zone {
    if (_instance == nil) {
        _instance = [super allocWithZone:zone];
    }
    return _instance;
}
@end
</code></pre>

<pre><code class="objectivec">// 使用

Demo *d1 = [[Demo alloc]init];
Demo *d2 = [[Demo alloc]init];
Demo *d3 = [Demo new];

NSLog(@"d1:%p d2:%p d3:%p", d1, d2, d3); // 可见地址都一样
</code></pre>

<p>使用懒加载的写法，如外界在很多子线程中 alloc，那么会有安全隐患问题</p>

<h2>解决多线程下的隐患</h2>

<pre><code class="objectivec">// 方法一: 加互斥锁，解决多线程访问安全问题

@implementation Demo

static Demo *_instance;

+ (instancetype)allocWithZone:(struct _NSZone *)zone {
    @synchronized(self) {
       if (_instance == nil) {
            _instance = [super allocWithZone:zone];
        }
    }
    return _instance; 
}
@end
</code></pre>

<pre><code class="objectivec">// 方法二: GCD 一次性代码，保证整个程序运行中，只执行一次，且线程安全

@implementation Demo

static Demo *_instance;

+ (instancetype)allocWithZone:(struct _NSZone *)zone {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        _instance = [super allocWithZone:zone];
    });

    return _instance; 
}
@end
</code></pre>

<h2>优化</h2>

<ul>
<li>为了外部方便调用，可像外部提供一个类方法，便于使用单例

<ul>
<li>方法名: <code>share + 类名</code> | <code>default + 类名</code> | <code>类名</code></li>
</ul>
</li>
</ul>


<pre><code class="objectivec">@interface Demo : NSObject

+ (instancetype)shareDemo;

@end

@implementation Demo

static Demo *_instance;

+ (instancetype)allocWithZone:(struct _NSZone *)zone {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        _instance = [super allocWithZone:zone];
    });

    return _instance; 
}

// 提供类方法，方便外界访问
+ (instancetype)shareDemo {
    // 调用 alloc 时，会调用 allocWithZone
    return [[self aloc]init];
}

// 严谨: 由于下面这两个方法也可获取到对象
// 所以也需重写一下，让他们得到的也是单例对象
- (id)copyWithZone:(NSZone *)zone {
    return _instance;
}
- (id)mutableCopyWithZone:(NSZone *)zone {
    return _instance;
}

@end
</code></pre>

<pre><code class="objectivec">// 使用

Demo *d1 = [Demo shareDemo];
Demo *d2 = [Demo new];
Demo *d3 = [Demo shareDemo];
Demo *d4 = [d1 copy];
Demo *d5 = [d1 mutableCopy];

NSLog(@"d1:%p d2:%p d3:%p d4:%p d5:%p", d1, d2, d3, d4, d5); // 可见地址都一样
</code></pre>

<h1><h2 id="mrc">MRC 环境下实现单例模式</h2></h1>

<pre><code class="objectivec">@implementation Demo

// 实现同 ARC 单例

#pragma mark - MRC中需要覆盖的方法
// 不需要计数器+1
- (id)retain {
    return self;
}

// 不需要，堆区的对象才需要
- (id)autorelease {
    return self;
}

// 不需要
- (oneway void)release {}

// 不需要计数器个数， 直接返回最大无符号整数
- (NSUInteger)retainCount {
    return UINT_MAX;  // 参照常量区字符串的 retainCount
}
@end
</code></pre>

<h1><h2 id="am">ARC 与 MRC 通用的单例</h2></h1>

<pre><code class="objectivec">@interface Demo : NSObject

+ (instancetype)shareDemo;

@end

@implementation Demo

static Demo *_instance;

+ (instancetype)allocWithZone:(struct _NSZone *)zone {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        _instance = [super allocWithZone:zone];
    });

    return _instance; 
}

// 提供类方法，方便外界访问
+ (instancetype)shareDemo {
    // 调用 alloc 时，会调用 allocWithZone
    return [[self aloc]init];
}

- (id)copyWithZone:(NSZone *)zone {
    return _instance;
}
- (id)mutableCopyWithZone:(NSZone *)zone {
    return _instance;
}

// 通过宏定义判断是否为 MRC 环境
#pragma mark - MRC 中需要覆盖的方法, ARC与MRC的整合  
#if !__has_feature(objc_arc)

- (id)retain {
    return self;
}

- (id)autorelease {
    return self;
}

- (oneway void)release {}

- (NSUInteger)retainCount {
    return UINT_MAX;
}  

#endif

@end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectiveC - Tricks]]></title>
    <link href="http://away0x.github.io/blog/2018/02/15/oc-tricks/"/>
    <updated>2018-02-15T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2018/02/15/oc-tricks</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#clserror">写类时的常见错误</a></li>
<li><a href="#const">常量</a></li>
<li><a href="#precompile">预编译</a></li>
<li><a href="#ssc">super &amp; superclass &amp; class</a></li>
<li><a href="#lazy">懒加载</a></li>
<li><a href="#foreach">foreach</a></li>
<li><a href="#timer">timer</a></li>
<li><a href="#predicate">predicate</a></li>
<li><a href="#ec">expression closures</a></li>
</ul>


<h1><h2 id="clserror">写类时的常见错误</h2></h1>

<ol>
<li>只有类的声明没有实现</li>
<li>漏了 @end</li>
<li>@interface 和 @implementation 嵌套</li>
<li>实例变量没有写在声明的大括号内</li>
<li>方法的声明写在了大括号内</li>
<li>实例变量不能再大括号内初始化、和访问权限的问题</li>
<li>方法不能当做函数一样调用</li>
<li>OC 方法不能独立于类存在</li>
<li>C 函数不属于类，C 函数只归定义函数的文件所有</li>
<li>C 函数不能访问 OC 对象的成员</li>
<li>方法有声明，但实现时写成了函数</li>
<li>static 不能用在实例变量和方法上，不要和 C 语言混淆</li>
</ol>


<h1><h2 id="const">常量</h2></h1>

<p>尽量使用类型常量，而不是使用宏定义</p>

<pre><code class="objectivec">// 定义字符串常量
static NSString * const STMProjectName = @"GCDFetchFeed";
</code></pre>

<h1><h2 id="precompile">预编译</h2></h1>

<pre><code class="objectivec">// 只在 mac 系统下输出
#if TARGET_OS_MAC
    NSLog(@"这是 mac 系统");
#endif

#define DEBUG_MODE 1
#if DEBUG_MODE
    NSLog(@"当前是调试模式"); // 输出这条
#else
    NSLog(@"当前不是调试模式");
#endif

#ifdef XX
    // 如果定义了 XX ，才会执行这里的代码
#endif
</code></pre>

<h1><h2 id="ssc">super &amp; superclass &amp; class</h2></h1>

<ul>
<li>class: 获取当前方法调用者的类</li>
<li>superclass: 获取当前方法调用者的父类</li>
<li>super: 仅仅是一个编译指示器，就是给编译器看的，不是一个指针

<ul>
<li>这和 super 不一样，self 是一个指针</li>
<li><code>NSLog(@"%@ %@", self, super)</code> 所以打印 self 可以，但是打印 super 会报错</li>
<li>只要编译器看到 super 这个标志，就会让当前对象去调用父类方法，<strong>本质还是当前对象在调用</strong>

<ul>
<li>所以 <code>[super class]</code> 等同于 <code>[self class]</code></li>
</ul>
</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">// SubPerson 继承了 Person

@implementation SubPerson

- (void)test {
    NSLog(
        @"%@ %@ %@ %@",
        [self class],      // SubPerson
        [self superclass], // Person
        [super class],     // SubPerson
        [super superclass] // Person
    );
}

@end
</code></pre>

<h1><h2 id="lazy">懒加载</h2></h1>

<ul>
<li>本质是重写 getter 方法。用到时候再加载，而且只加载一次</li>
<li>代码创建 UI 常用懒加载</li>
</ul>


<pre><code class="objectivec">// 以懒加载一个UIImageView控件为例
- (UIImageView *)imageView {
    if ( ! _imageView) {
        _imageView = [[UIImageView alloc]init];
        // 设置 属性
    }
    return _imageView;
}
</code></pre>

<h1><h2 id="foreach">foreach</h2></h1>

<pre><code class="objectivec">// 让数组中的每个元素都执行 removeFromSuperview 该方法
[self.view.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];
</code></pre>

<h1><h2 id="timer">timer</h2></h1>

<pre><code class="objectivec">// ---------------- 头文件 ----------------------
@interface MyTimer : NSObject
- (void) testTimer;
@end

// ---------------- 实现文件 ----------------------
// 定义定时器
@interface MyTimer() {
    NSTimer *timer1;
    NSTimer *timer2;
}

@end

@implementation MyTimer
- (void) testTimer {
    // 1. 手动添加到 RunLoop
    // 参数1：中断间隔，参数2：响应方法对象，参数3：响应方法，参数4：传递参数，参数5：是否重复
    timer1 = [NSTimer timerWithTimeInterval: 1 target: self selector: @selector(myLog) userInfo:
        nil repeats: false];
    [[NSRunLoop currentRunLoop] addTimer: timer1 forMode: NSDefaultRunLoopMode];
    [[NSRunLoop currentRunLoop] run];

    // 2. 自动添加到 RunLoop + 带参定时器
    // 用这个方法的话，如当前线程中有 RunLoop，则会自动添加进去
    timer2 = [NSTimer scheduledTimerWithTimeInterval: 1 target: self selector: @selector(myLog:)
        userInfo: @"world" repeats: false];
    [timer2 fire];

    // 3. 定时精度 0.01s = 10ms = 0.01 * 1000 只能粗略的计算
    timer1 = [NSTimer timerWithTimeInterval: 0.01 target: self selector: @selector(myLog) userInfo:
        nil repeats: true];
    [[NSRunLoop currentRunLoop] addTimer: timer1 forMode: NSDefaultRunLoopMode];
    [[NSRunLoop currentRunLoop] run];

    // 4. 如何快速的打印出当前代码的执行时间
    NSDate *timerMark = [NSDate date]; // 当前时间
    // 要执行的代码放这中间......
    NSTimeInterval timerInterval = [timeMark timeIntervalSinceNow]; // 执行结束时间
    float timeNow = 0 - timeInterval; // 时间转为正数
    NSLog(@"timeNow=%f", timeNow);
}
- (void) myLog {
    NSLog(@"我是一个定时器");
}
// 带参数的定时器
- (void) myLog:(NSTimer*)timer {
    NSLog(@"hello %@", timer2.userInfo); // "hello world"
}
@end

// ---------------- 执行文件 ----------------------
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        MyTimer *timer = [[MyTimer alloc] init];
        [timer testTimer];
    }
}
</code></pre>

<h1><h2 id="predicate">predicate</h2></h1>

<p>按一定的条件对数据进行处理和过滤</p>

<pre><code class="objectivec">// 对数组中的元素进行过滤

NSArray *arr1 = [[NSArray
    alloc] initWithObjects:@"ios",@"android",@"wp", nil];

// 1. 创建谓词对象 2. 指定过滤条件
NSPredicate *pre1 = [NSPredicate
    predicateWithFormat:@"SELF == 'android'"]; // SELF 是数组的每一项
// 3. 过滤条件应用到对象上
NSArray *arr2 = [arr1 filteredArrayUsingPredicate:pre1];

for (NSString *item in arr2) {
    NSLog(@"%@", item); // android
}
</code></pre>

<pre><code class="objectivec">// 得到数组中大于 10 的元素

NSString *num1 = [NSString stringWithFormat:@"%d", 3];
NSString *num2 = [NSString stringWithFormat:@"%d", 15];

NSArray *arr1 = [[NSArray alloc] initWithObjects:num1,num2, nil];

// 使用谓词
NSPredicate *pre1 = [NSPredicate
    predicateWithFormat:@"SELF.initValue &gt; 10"];
NSArray *arr2 = [arr1 filteredArrayUsingPredicate:pre1];

for (NSString *item in arr2) {
    NSLog(@"%d", item.initValue); // 15
}
</code></pre>

<pre><code class="objectivec">// 谓词关键词
// 数组中是否包含某个元素(使用关键词)

NSArray *arr1 = [[NSArray alloc] initWithObjects:@"abc",@"def", nil];

NSPredicate *pre1 = [NSPredicate
    predicateWithFormat:@"SELF CONTAINS %@",@"def"]; // CONTAINS: SELF 包含某些内容
NSArray *arr2 = [arr1 filteredArrayUsingPredicate:pre1];

for (NSString *item in arr2) {
    NSLog(@"%@", item); // "def"
}
</code></pre>

<pre><code class="objectivec">// 过滤对象
// 过滤出 age 属性为 10 的对象
Person *p1 = [[Person alloc] init];
p1.age = 10;
Person *p2 = [[Person alloc] init];
p2.age = 30;

NSMutableArray *arr1 = [[NSMutableArray alloc] init];
[arr1 addObject:p1];
[arr1 addObject:p2];
NSLog(@"%p %p", p1, p2); // 打印地址

NSPredicate *pre1 = [NSPredicate
    predicateWithFormat:@"age == %d",10];
NSArray *arr2 = [arr1 filteredArrayUsingPredicate:pre1];

for (Person *p in arr2) {
    NSLog(@"%p", p); // 打印地址
}
</code></pre>

<h1><h2 id="ec">expression closures</h2></h1>

<pre><code class="objectivec">// 会将代码块 ({}) 里最后一个表达式 return 出来

#define ScreenWidth [UIScreen mainScreen].bounds.size.width
static NSString * const ID = @"cell";

// UICollectionView 布局
UICollectionViewFlowLayout *layout = ({
    UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc]init];
    layout.itemSize = CGSizeMake(160, 160);
    layout.minimumLineSpacing = 50; // 最小行间距
    // layout.minimumInteritemSpacing = 0; // item 的最小间距
    layout.scrollDirection = UICollectionViewScrollDirectionHorizontal; // 滚动方向
    // 内边距
    CGFloat margin = (ScreenWidth - 160) * 0.5;
    layout.sectionInset = UIEdgeInsetsMake(0, margin, 0, margin);

    layout; // 相当于将这个值 return 出去了
});

// UICollectionView 创建
UICollectionView *collectionView = ({
    UICollectionView *collectionView = [[UICollectionView alloc]initWithFrame:CGRectZero collectionViewLayout:layout];
    collectionView.backgroundColor = [UIColor brownColor];
    collectionView.center = self.view.center;
    collectionView.bounds = CGRectMake(0, 0, self.view.bounds.size.width, 200);
    collectionView.dataSource = self;
    collectionView.showsHorizontalScrollIndicator = NO; // 隐藏水平滚动条

    collectionView; // 相当于将这个值 return 出去了
});

// 注册 cell
[collectionView
    registerNib:[UINib nibWithNibName:
        NSStringFromClass([MyCollectionViewCell class]) bundle:nil]
    forCellWithReuseIdentifier:ID];

[self.view addSubview:collectionView];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectiveC - Typedef, Generic, Enum, @class]]></title>
    <link href="http://away0x.github.io/blog/2018/02/11/oc-typedef-generic-enum-class/"/>
    <updated>2018-02-11T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2018/02/11/oc-typedef-generic-enum-class</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#typedef">typedef</a></li>
<li><a href="#generic">generic</a></li>
<li><a href="#enum">enum</a></li>
<li><a href="#class">@class</a></li>
</ul>


<h1><h2 id="typedef">typedef</h2></h1>

<pre><code class="objectivec">// 未使用别名
enum IColor {
    kIColorBlack,
    kIColorWhite
}

@interface Iphone : NSObject {
    enum IColor _color; // 类型名很长
}

@end

@implementation Iphone

@end

// 使用别名
typedef enum {
    kIColorBlack,
    kIColorWhite
} IColor;

@interface Iphone : NSObject {
    IColor _color; // 使用类型别名
}

@end

@implementation Iphone

@end

// 使用
int main(int argc, const char * argv[]) {
    Iphone *p = [Iphone new];
    p-&gt;_color = kIColorBlack;

    return 0;
}
</code></pre>

<h1><h2 id="generic">generic</h2></h1>

<blockquote><p>iOS9+</p></blockquote>

<ol>
<li>用于限制类型</li>
<li>提高代码规划，减少沟通成本</li>
<li>限制集合里的存储类型，不限制的话都是 id 类型

<ul>
<li>限制后只能存储对应类型，且由于有了具体类型，取出时可以使用点语法</li>
<li>id 类型是不能使用点语法的</li>
</ul>
</li>
<li>泛型仅仅是报警告</li>
</ol>


<pre><code class="objectivec">// 不用泛型 --------
// 属性
@property (nonatomic, strong) NSMutableArray *arr;

// 使用
[_arr addObject:@"112"]; // 由于定义时没用泛型，所以这里 add 进去的其实是 id 类型
_arr[0].length; // 报错，_arr[0] 里面是 id 类型，id 类型不能使用点语法

// 使用泛型 --------
// 属性
@property (nonatomic, strong) NSMutableArray&lt;NSString *&gt; *arr;

// 使用
[_arr addObject:@"112"]; // add 的是 NSString 类型
_arr[0].length; // 不报错，数组里是 NSString 类型
</code></pre>

<pre><code class="objectivec">// 参数
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
</code></pre>

<pre><code class="objectivec">// 限定类型
@interface Test&lt;ObjectType&gt; : NSObject
@property (nonatomic, strong) ObjectType language;
@end

// 使用
Java *java = [[Java alloc] init];
iOS *ios = [[iOS alloc] init];

Test&lt;iOS *&gt; *t = [[Test alloc] init];
t.language = ios;  // 泛型限制了，这里只能设置 iOS 类型
t.language = java; // 报警告
</code></pre>

<h1><h2 id="enum">enum</h2></h1>

<pre><code class="objectivec">// 第一种写法 (无法设置枚举值类型)
typedef enum {
    DemoTypeTop,
    DemoTypeBottom,
} DemoType;

// 第二种写法 (可设置枚举值类型)
typedef NS_ENUM(NSInteger, DemoType) {
    DemoTypeTop,
    DemoTypeBottom,
};

// 第三种写法 (位移枚举)
// 更强大，使用时可用并运算
typedef NS_OPTIONS(NSInteger, DemoType) {
    DemoTypeTop = 1 &lt;&lt; 0,    // 1*2^0 = 1
    DemoTypeBottom = 1 &lt;&lt; 1, // 1*2^1 = 2
    DemoTypeLeft = 1 &lt;&lt; 2,   // 1*2^2 = 4
    DemoTypeRight = 1 &lt;&lt; 3,  // 1*2^3 = 8
};
</code></pre>

<p>位移枚举可进行位运算</p>

<pre><code class="objectivec">// 按位与 &amp;
//    1&amp;1==1 1&amp;0==0 0&amp;0==0
//    总结: 只有有 0 则为 0
// 按位或 |
//    1|1==1 1|0==1 0|0==0
//    总结: 只有有 1 则为 1

- (void)demo:(DemoType)type {
    if (type &amp; DemoTypeTop) {
        NSLog(@"top --- %zd", type &amp; DemoTypeTop);
    }
    if (type &amp; DemoTypeBottom) {
        NSLog(@"bottom --- %zd", type &amp; DemoTypeBottom);
    }
    if (type &amp; DemoTypeLeft) {
        NSLog(@"left --- %zd", type &amp; DemoTypeLeft);
    }
    if (type &amp; DemoTypeRight) {
        NSLog(@"right --- %zd", type &amp; DemoTypeRight);
    }
}

- (void)test {
    [self demo:DemoTypeTop | DemoTypeRight]; // 打印 top 和 right
    [self demo:0]; // 什么都不会打印

    // 小技巧
    // 如是位移枚举，可观察第一个枚举值，如该枚举值不为 0
    // 那么可默认传 0 做参数，如传 0，那么效率最高 (因为什么额外操作都不会做)
}
</code></pre>

<h2>枚举中的位运算</h2>

<ul>
<li>位移枚举，可以使用并运算 <code>|</code></li>
<li>一般情况下，如方法参数是枚举值，那么可用过 <code>|</code> 符号，连接多个枚举值</li>
</ul>


<pre><code class="objectivec">NSDate *now = [NSDate date];
NSCalendar *calendar = [NSCalendar currentCalendar];

// 分别获取 年月日时分秒
// 如方法参数是位移枚举，那么可用过 | 符号，连接多个枚举值
NSCalendarUnit type = NSCalendarUnitYear |
                      NSCalendarUnitMonth |
                      NSCalendarUnitDay |
                      NSCalendarUnitHour |
                      NSCalendarUnitMinute |
                      NSCalendarUnitSecond;
NSDateComponents *cmps = [calendar components:type fromDate:now];
NSLog(@"year = %ld", cmps.year);
NSLog(@"month = %ld", cmps.month);
NSLog(@"day = %ld", cmps.day);
NSLog(@"hour = %ld", cmps.hour);
NSLog(@"minute = %ld", cmps.minute);
NSLog(@"second = %ld", cmps.second);
</code></pre>

<h1><h2 id="class">@class</h2></h1>

<p>作用: 可以简单的引用一个类</p>

<ul>
<li><p>简单使用: <code>@class Dog;</code> 仅仅是告诉编译器: Dog 是一个类，并不会包含 Dog 这个类的所有内容</p></li>
<li><p><code>@class:</code> 在 <code>.h</code> 文件中使用 <code>@class</code> 引用一个类</p>

<ul>
<li>仅仅只是告诉编译器，<code>@class</code>后面的名称是一个类，不会做任何拷贝操作</li>
<li>注意: 编译器不会知道这个类中有哪些属性和方法，所以在 <code>.m</code> 中使用这个类时，需要 import 这个类，才能使用</li>
</ul>
</li>
<li><code>#import:</code>在 <code>.m</code> 文件中使用 <code>#import</code> 包含这个类的 <code>.h</code> 文件

<ul>
<li>会将整个文件的代码拷贝到 import 所在的位置</li>
<li>只要 import 的文件发生了改变，那么 import 就会重新拷贝一次 (更新操作)

<ul>
<li>多个类时，编译效率变慢</li>
</ul>
</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">// Person2.h 中
@class Person1; // 该文件中引入 Person1 类

// Person2.m 中
#import "Person1.h"
</code></pre>

<p>如果在 A 类中要包含 B类，B 类中又要包含 A 类，则 <code>.h</code> 中一定要用 <code>@class</code> 避免循环引入</p>

<ul>
<li>总结:

<ol>
<li>在 <code>.h</code> 中使用 <code>@class</code> 引用一个类</li>
<li>在 <code>.m</code> 文件中使用 <code>#import</code> 包含这个类的 <code>.h</code> 文件</li>
</ol>
</li>
</ul>


<h2>@class 其他应用场景</h2>

<p>对于循环依赖关系来说，比方 A 类引用 B 类，同时 B 类也引用 A 类</p>

<pre><code class="objectivec">// 这种嵌套包含的代码编译会报错
#import "B.h"
@interface A : NSObject {
    B *_b;
}
@end

#import "A.h"
@interface B : NSObject {
    A *_a;
}
@end
</code></pre>

<pre><code class="objectivec">// 当使用 @class 在两个类相互声明，就不会出现编译报错

@class B
@interface A : NSObject {
    B *_b;
}
@end

@class A
@interface B : NSObject {
    A *_a;
}
@end
</code></pre>

<h2>@class 和 #import 的区别</h2>

<ul>
<li>作用上的区别

<ul>
<li>import 会包含引用类的所有信息(内容)，包括引用类的变量和方法</li>
<li>@class 仅仅是告诉编译器有这么个类，具体这个类有什么信息，完全不知</li>
</ul>
</li>
<li>效率上的区别

<ul>
<li>如果有上百个头文件都 <code>#import</code> 了同一个文件，或者这些文件依次被 <code>#import</code>，那么一旦最开始的头文件有所改动，后面引用到这个文件的所有类都需要重新编译一遍，编译效率非常低</li>
<li>相对来讲，使用 <code>@class</code> 就不会出现这个问题了</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ObjectiveC - Const, Static, Extern]]></title>
    <link href="http://away0x.github.io/blog/2018/02/10/oc-const-static-extern/"/>
    <updated>2018-02-10T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2018/02/10/oc-const-static-extern</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#const">const</a></li>
<li><a href="#static">static</a></li>
<li><a href="#extern">extern</a></li>
</ul>


<h1><h2 id="const">const</h2></h1>

<blockquote><p>苹果推荐使用 const 常量替代宏字符串常量</p></blockquote>

<h2>const 与宏的区别</h2>

<ol>
<li><strong>编译时刻:</strong> 宏是<strong>预编译</strong>(编译之前处理)，const 是<strong>编译阶段</strong></li>
<li><strong>编译检查:</strong> 宏不做检查，不会报编译错误，只是替换，const 会编译检查，会报编译错误</li>
<li><strong>宏的好处:</strong> 宏能定义一些函数、方法。const 则不能</li>
<li><strong>宏的坏处:</strong> 使用大量宏，容易造成编译时间久，每次都需要重新替换</li>
</ol>


<pre><code class="objectivec">// 宏
#define MyAccount @"account"
#define MyUserDefault [NSUserDefaults standardUserDefaults]

// 字符串常量
static NSString * const account = @"account";

- (void)viewDidLoad {
    [super viewDidLoad];

    // 使用宏
    [MyUserDefault setValue:@"123", forKey:MyAccount];

    // 使用 const 常量
    [[NSUserDefaults standardUserDefaults] setValue:@"123", forKey:account];
}
</code></pre>

<h2>使用</h2>

<ul>
<li>作用

<ol>
<li>修饰右边的基本变量或指针变量</li>
<li>被 cosnt 修饰的变量是只读的</li>
</ol>
</li>
<li>使用场景

<ol>
<li>修饰全局只读变量</li>
<li>修饰方法中只读参数</li>
</ol>
</li>
</ul>


<pre><code class="objectivec">int a = 3;
a = 5; // 可以修改

int const b = 3; // 也可这样写 const int b = 3;
b = 5; // 不可修改，报错
</code></pre>

<pre><code class="objectivec">// const 修饰指针变量

int a = 3;
int *p = &amp;a;
NSLog(@"%d", a); // 3
a = 5;
NSLog(@"%d", a); // 5
*p = 8;
NSLog(@"%d", a); // 8

// const 修饰 *p
int a = 3;
int b = 5;
int const *p = &amp;a;
p = &amp;b; // p 可以修改
*p = 8; // *p 被 const 修饰了，不可修改，会报错

// const 修饰 p
int a = 3;
int b = 5;
int * const p = &amp;a;
p = &amp;b; // p 被 const 修饰了，不可修改，会报错
*p = 8; // *p 可被修改
</code></pre>

<pre><code class="objectivec">int * const p;       // p: 不可修改，*p: 可修改
int const *p;        // p: 可修改，  *p: 不可修改
const int * p;       // p: 可修改，  *p: 不可修改
const int * const p; // p: 不可修改，*p: 不可修改
int const * const p; // p: 不可修改，*p: 不可修改
</code></pre>

<h1><h2 id="static">static</h2></h1>

<ol>
<li>修饰局部变量，被其修饰的局部变量，会延长生命周期，生命长度跟整个应用程序有关

<ul>
<li>被 static 修饰的局部变量，只会分配一次内存</li>
<li>被 static 修饰的局部变量，程序一运行就会给其分配内存</li>
</ul>
</li>
<li>修饰全局变量，被 static 修饰的全局变量，作用域会修改，只能在当前文件下使用</li>
</ol>


<h2>static 和 const 联合使用</h2>

<ul>
<li>cosnt 修饰全局变量，使其只读</li>
<li>static 修饰全局变量，使其作用域为文件作用域</li>
</ul>


<pre><code class="objectivec">// 只在当前文件中可访问到的只读全局变量
static NSString * const name = @"wt";

@implementation ViewController
@end
</code></pre>

<h1><h2 id="extern">extern</h2></h1>

<ol>
<li>用于声明(使用)外部全局变量，<strong>注意: 其只能用于声明，不能用于定义</strong></li>
<li>工作原理: 先会去当前文件下查找有无对应全局变量，如没有，才会去其他文件查找</li>
<li>全局变量在程序运行时就会分配，如 A 文件中定义了全局变量 <code>int a = 0</code>，在 B 文件中可用 <code>extern int a</code> 来使用它</li>
<li>如该全局变量使用 static 修饰，那么 extern 无法找到它，因为其是文件作用域</li>
</ol>


<h2>extern 和 const 联合使用</h2>

<pre><code class="objectivec">// A 类
NSString * const a = @"a";

@implementation A
@end
</code></pre>

<pre><code class="objectivec">// 使用全局变量 a
extern NSString *a;

@implementation B

- (void)test {
    NSLog(@"%@", a); // "a" 可读到
    a = @"aa";       // 报错，a 被 const 修饰了，不可修改
}

@end
</code></pre>

<h2>注意点</h2>

<ul>
<li>注意: 全局变量不能定义在自己的类中

<ul>
<li>如多个文件声明了同名的全局变量，会编译失败</li>
</ul>
</li>
<li>可自己创建一个管理全局变量的类，如 <code>GlobeConst</code>

<ul>
<li>在 m 文件中定义全局变量，在 h 中使用 extern 引用，这样其他文件要使用这些全局变量，只要引用 <code>GlobeConst.h</code> 文件即可</li>
<li><code>GlobeConst</code> 中的全局变量使用 const 修饰，避免其他文件使用时对其修改了</li>
</ul>
</li>
</ul>


<pre><code class="objectivec">// GlobeConst.h

extern NSString * const one_name;
</code></pre>

<pre><code class="objectivec">// GlobeConst.m

NSString * const one_name = @"one name";
</code></pre>

<pre><code class="objectivec">// 其他文件

#import "GlobeConst.h"

NSLog(@"%@", one_name); // "one name"
</code></pre>
]]></content>
  </entry>
  
</feed>
