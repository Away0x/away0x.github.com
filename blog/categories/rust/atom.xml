<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rust | Away0x's Blog]]></title>
  <link href="http://away0x.github.io/blog/categories/rust/atom.xml" rel="self"/>
  <link href="http://away0x.github.io/"/>
  <updated>2022-05-28T21:02:30+08:00</updated>
  <id>http://away0x.github.io/</id>
  <author>
    <name><![CDATA[TongWu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rust - Macro, Unsafe]]></title>
    <link href="http://away0x.github.io/blog/2021/10/14/rust-macro-unsafe/"/>
    <updated>2021-10-14T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2021/10/14/rust-macro-unsafe</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#Macro">Macro</a></li>
<li><a href="#Unsafe">Unsafe</a></li>
</ul>


<h2><h2 id="Macro">Macro</h2></h2>

<ul>
<li>macro 在 Rust 里指的是一组相关特性的集合称谓:

<ul>
<li>使用 <code>macro_rules!</code> 构建声明宏 (declarative macro)</li>
<li>三种过程 macro

<ol>
<li>自定义 <code>#[derive]</code> 宏, 用于 struct 或 enum, 可以为其指定随 derive 属性添加的代码</li>
<li>类似属性的宏, 在任何条目上添加自定义属性</li>
<li>类似函数的宏, 看起来像函数调用, 对其指定为参数的 token 进行操作</li>
</ol>
</li>
</ul>
</li>
</ul>


<h3>函数与宏的区别</h3>

<ol>
<li>本质上，宏是用来编写可以生成其他代码的代码 (元编程 metaprogramming)</li>
<li>函数在定义签名时，必须声明参数的个数和类型, 宏可处理可变的参数</li>
<li>编译器会在解释代码前展开宏</li>
<li>宏的定义比函数复杂得多, 难以阅读、理解、维护</li>
<li>在某个文件调用宏时,必须提前定义宏或将宏引入当前作用域</li>
<li>函数可以在任何位置定义并在任何位置使用</li>
</ol>


<h3>声明宏 <code>macro_rules!</code> (可能被弃用)</h3>

<pre><code class="rust">// 简化版的 vec! 实现
#[macro_export]
macro_rules! vec {
( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
</code></pre>

<pre><code class="rust">#![allow(unused)] // 允许代码中保留未使用的函数或变量，其是一个属性宏
macro_rules! calculate {
    // (eval 1 + 2)
    // $e:expr 表示 $e 这个宏变量的类型是 expr(表达式类型), 即 1 + 2
    (eval $e:expr) =&gt; { {
        {
            let val: usize = $e; // Force types to be integers
            println!("{} = {}", stringify!{$e}, val);
        }
    } };
}

fn main() {
    calculate! {
        eval 1 + 2
    }
    calculate! {
        eval (1 + 2) * (3 / 1)
    }
}
</code></pre>

<h3>基于属性来生成代码的过程宏</h3>

<ul>
<li>会接收并操作输入的 Rust 代码, 生成另外一些 Rust 代码作为结果</li>
<li>有三种过程宏

<ol>
<li>自定义派生</li>
<li>属性宏</li>
<li>函数宏</li>
</ol>
</li>
<li>创建过程宏时:

<ul>
<li>宏定义必须单独放在它们自己的包中,并使用特殊的包类型</li>
</ul>
</li>
</ul>


<pre><code class="rust">use proc_macro;

#[some_attribute] // 用于指定过程宏的占位符
pub fn some_name(input: TokenStream) -&gt; TokenStream {}
</code></pre>

<h3>类似函数的宏</h3>

<ul>
<li>函数宏定义类似于函数调用的宏, 但比普通函数更灵活</li>
</ul>


<pre><code class="rust">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {}

// 使用 let sql = sql!(SELECT * FROM posts WHERE id=1);
</code></pre>

<h2><h2 id="Unsafe">Unsafe</h2></h2>

<ul>
<li>Unsafe Rust: 没有强制的安全保证</li>
<li>Unsafe Rust 存在的原因:

<ol>
<li>静态分析是保守的

<ul>
<li>使用 Unsafe Rust 我知道自己在做什么, 并承担相应风险</li>
</ul>
</li>
<li>计算机硬件本身就是不安全的, Rust 需要能够进行底层系统编程</li>
</ol>
</li>
<li>Unsafe 代码块里可执行的四个动作

<ol>
<li>解引用原始指针</li>
<li>调用 unsafe 函数或方法</li>
<li>访问或修改可变的静态变量</li>
<li>实现 unsafe trait</li>
</ol>
</li>
<li>注意:

<ul>
<li>unsafe 并没有关闭借用检查或停用其他安全检查</li>
<li>任何内存相关的错误必须留在 unsafe 块里</li>
<li>尽可能隔离 unsafe 代码,最好将其封装在安全的抽象里, 提供安全的 API</li>
</ul>
</li>
</ul>


<h3>解引用原始指针</h3>

<ul>
<li>原始指针:

<ul>
<li>可变的: <code>*mut T</code></li>
<li>不可变的: <code>*const T</code>. 意味着指针在解引用后不能直接对其进行赋值</li>
<li>注意: 这里的 <code>*</code> 不是解引用符号, 它是类型名的一部分</li>
</ul>
</li>
<li>与引用不同, 原始指针:

<ul>
<li>允许通过同时具有不可变和可变指针或多个指向同一位置的可变指针来忽略借用规则</li>
<li>无法保证能指向合理的内存</li>
<li>允许为 null</li>
<li>不实现任何自动清理</li>
</ul>
</li>
<li>放弃保证的安全, 换取更好的性能/与其他语言或硬件接口的能力</li>
<li>为啥要使用原始指针:

<ul>
<li>与 C 语言进行接口</li>
<li>构建借用检查器无法理解的安全抽象</li>
</ul>
</li>
</ul>


<pre><code class="rust">fn main() {
    let mut num = 5;

    // 可以在 unsafe 外面创建原始指针
    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;

    // 只能在 unsafe 内对原始指针进行解引用
    unsafe {
        println!("{}", *r1);
        println!("{}", *r2);
    }

    let addr = 0x012345usize;
    let r3 = addr as *const i32; // 有问题的地址, 编译不会报错
    unsafe {
        println!("{}", r3); // 运行时报错
    }
}
</code></pre>

<h3>调用 unsafe 函数或方法</h3>

<ul>
<li>unsafe 函数或方法: 在定义前加上了 unsafe 关键字

<ul>
<li>调用前需手动满足一些条件 (主要靠看文档), 因为 Rust 无法对这些条件就行验证</li>
<li>需要在 unsafe 块里进行调用</li>
</ul>
</li>
</ul>


<pre><code class="rust">unsafe fn dangerous() {}

fn main() {
    unsafe {
        dangerous();
    }
}
</code></pre>

<h3>创建 unsafe 代码的安全抽象</h3>

<ul>
<li>函数包含 unsafe 代码并不意味着需要将整个函数标记为 unsafe</li>
<li>将 unsafe 代码包裹在安全函数中是一个常见的抽象</li>
</ul>


<h3>使用 extern 函数调用外部代码</h3>

<ul>
<li>extern 关键字: 简化成绩和使用外部函数接口 (FFI) 的过程

<ul>
<li>FFI (Foreign Function Interface): 外部函数接口, 它允许一种编程语言定义函数, 并让其他编程语言能调用这些函数</li>
</ul>
</li>
<li>可以使用 extern 来创建一个允许其他语言调用 Rust 函数的接口</li>
</ul>


<pre><code class="rust">// 任何在 extern 块里声明的函数都是 unsafe 的
extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
</code></pre>

<h3>访问或修改可变静态变量</h3>

<pre><code class="rust">static HELLO_WORLD: &amp;str = "Hello, world!";

fn main() {
    println!("name is: {}", HELLO_WORLD);
}
</code></pre>

<pre><code class="rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
</code></pre>

<h3>实现不安全 trait</h3>

<ul>
<li>当某个 trait 中存在至少一个方法拥有编译器无法校验的不安全因素时, 就称这个 trait 是不安全的</li>
</ul>


<pre><code class="rust">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rust - Pattern Match]]></title>
    <link href="http://away0x.github.io/blog/2021/10/13/rust-pattern-match/"/>
    <updated>2021-10-13T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2021/10/13/rust-pattern-match</id>
    <content type="html"><![CDATA[<ul>
<li>模式是 Rust 的一种特殊语法，用于匹配复杂和简单类型的结构</li>
<li>将模式与匹配表达式和其他构造结合使用，可以更好地控制程序的控制流</li>
<li>模式由以下元素 (的一些组合) 组成:

<ul>
<li>字面值</li>
<li>解构的数组、enum、struct 和 tuple</li>
<li>变量</li>
<li>通配符</li>
<li>占位符</li>
</ul>
</li>
<li>想要使用模式，需要将其与某个值比较

<ul>
<li>如果可以模式匹配，就可以在代码中使用这个值的相应部分</li>
</ul>
</li>
</ul>


<h2>可用用到模式匹配的地方</h2>

<h3>match 的分支</h3>

<ul>
<li>要求分支需要包含所有的可能性

<ul>
<li><code>_</code>: 可以匹配任何东西，不会绑定到变量，通常用于 match 的最后一个分支，或用于忽略某些值</li>
</ul>
</li>
</ul>


<pre><code class="rust">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>

<pre><code class="rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre>

<h3>if let</h3>

<ul>
<li>简单的控制流表达式，处理只关心一种匹配而忽略其他匹配的情况，放弃了穷举的可能性，可以理解成 match 的简化版</li>
<li>主要是作为一种简短的方式来等价的代替只有一个匹配项的 match</li>
<li><code>if let</code> 可选的可以拥有 <code>else</code> <code>else if</code> <code>else if let</code></li>
<li><code>if let</code> 不会检查穷尽性</li>
</ul>


<pre><code class="rust">let v = Some(0u8);

match v {
    Some(3) =&gt; println!("three"),
    _ =&gt; println!("others"),
}

// 可使用 if let 改写
if let Some(3) = v {
    println!("three");
} else {
    println!("others");
}
</code></pre>

<h3>while let 条件循环</h3>

<ul>
<li>只有模式继续满足匹配的条件，那它运行 while 循环一直运行</li>
</ul>


<pre><code class="rust">let mut stack = vec![1, 2, 3];
while let Some(top) = stack.pop() {
    println!("{}", top);
}
</code></pre>

<h3>for 循环</h3>

<pre><code class="rust">let arr = vec!['a', 'b', 'c'];
for (i, v) in arr.iter().enumerate() {
    println!("{}: {}", i, v);
}
</code></pre>

<h3>let 语句</h3>

<pre><code class="rust">let a = 5; // 这个其实也是一个模式
let (x, y, z) = (1, 2, 3);
</code></pre>

<h3>函数参数</h3>

<pre><code class="rust">fn foo(x: i32) {} // 参数 x 也是一个模式
fn foo2(&amp;(x, y): &amp;(i32, i32)) {}

let point = (3, 5);
foo2(&amp;point);
</code></pre>

<h2>模式的可辩驳性</h2>

<ul>
<li>模式有两种形式: 可辩驳的(可失败的), 无可辩驳的(不可失败的)

<ul>
<li>能匹配任何可能传递的值的模式: 无可辩驳的

<ul>
<li>例如: <code>let x = 5</code></li>
</ul>
</li>
<li>对于某些可能的值，无法继续匹配的模式: 可辩驳的

<ul>
<li>例如: <code>if let Some(x) = val</code></li>
</ul>
</li>
</ul>
</li>
<li>函数参数、let 语句、for 循环只接收<strong>无可辩驳</strong>的模式</li>
<li><code>if let</code> 和 <code>while let</code> 接收<strong>可辩驳</strong>和<strong>无可辩驳</strong>的模式</li>
<li>match 语句，除了最后一个分支是<strong>无可辩驳</strong>的，其他分支为<strong>可辩驳</strong></li>
</ul>


<h2>匹配语法</h2>

<h3>匹配字面值</h3>

<pre><code class="rust">let x = 1;

match x = {
    1 =&gt; println!("one"),
    2 =&gt; println!("two"),
    3 =&gt; println!("three"),
    _ =&gt; println!("anything"),
}
</code></pre>

<h3>匹配命名变量</h3>

<ul>
<li>命名的变量是可匹配任何值的无可辩驳模式</li>
</ul>


<pre><code class="rust">let x = Some(5);
let y = 10;

match x = {
    Some(50) =&gt; println!("Got 50"),
    Some(y) =&gt; println!("Matched, y = {:?}", y), // 作用域只在子句中
    _ =&gt; println!("Default case, x = {:?}", x),
}

println!("at the end: x = {:?}, y = {:?}", x, y);
// "Matched, y = 5"
// "at the end: x = Some(5), y = 10"
</code></pre>

<h3>多重模式</h3>

<ul>
<li>match 可使用 <code>|</code>(或运算符), 可以匹配多种模式</li>
</ul>


<pre><code class="rust">let x = 1;

match x {
    1 | 2 =&gt; println!("one or two"),
    3 =&gt; println!("three"),
    _ =&gt; println!("anything"),
}
</code></pre>

<h3>匹配范围</h3>

<pre><code class="rust">let x = 5;

match x {
    1..=5 =&gt; println!("one through five"), // 1,2,3,4,5
    _ =&gt; println!("something else"),
}
</code></pre>

<h3>使用模式来解构分解值</h3>

<pre><code class="rust">// 解构 struct
struct Point { x: i32, y: i32, }

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);

    match p {
        // 子分支会创建 x y 变量
        // 匹配 x = any, y = 0 的 Point
        Point { x, y: 0 } =&gt; println!("On the x axis at {}", x),
        // 匹配 x = 0, y = any 的 Point
        Point { x: 0, y } =&gt; println!("On the y axis at {}", y), // 匹配到该行
        // 匹配 x = any, y = any 的 Point
        Point { x, y } =&gt; println!("On neither axis: ({}, {})", x, y),
    }
}
</code></pre>

<pre><code class="rust">// 解构 enum
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {...}
        // 会创建 x y 变量
        Message::Move { x, y } =&gt; {...}
        Message::Write(text) =&gt; {...},
        Message::ChangeColor(r, g, b) =&gt; {...}
    }
}
</code></pre>

<pre><code class="rust">// 解构嵌套的类型
enum Color {
   Rgb(i32, i32, i32),
   Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {...}
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {...}
        _ =&gt; ()
    }
}
</code></pre>

<pre><code class="rust">// 解构 tuple
let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
</code></pre>

<h4>在模式中忽略值</h4>

<ul>
<li><code>_</code>: 可用来忽略某个值</li>
<li>使用以 <code>_</code> 开头的名称: 标记该值不会被用到</li>
<li><code>..</code>: 忽略值的剩余部分</li>
</ul>


<pre><code class="rust">// 使用 `_` 来作为匹配但不绑定任何值的通配符
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}

// --------
let mut setting_value = Some(5);
let new_setting_value = Some(10);
match (setting_value, new_setting_value) {
    (Some(_), Some(_)) =&gt; {
        println!("Can't overwrite an existing customized value");
    }
    _ =&gt; {
        setting_value = new_setting_value;
    }
}
println!("setting is {:?}", setting_value);

// --------
let numbers = (2, 4, 8, 16, 32);
match numbers {
    (first, _, third, _, fifth) =&gt; {
        println!("Some numbers: {}, {}, {}", first, third, fifth)
    },
}
</code></pre>

<pre><code class="rust">// 使用以 `_` 开头的名称: 忽略被使用的变量
let _x = 5; // _x 没被使用也不会有警告

// -------
let s = Some(String::from("Hello!"));
// s 多所有权被移入了 if let 子句了, _s 会发生绑定操作获取所有权
// 如果将 Some(_s) 修改为 Some(_)，_ 不会发生绑定操作，所以 s 的所有权也不会移动了
if let Some(_s) = s {
    println!("found a string");
}
</code></pre>

<pre><code class="rust">// 用 .. 忽略剩余值
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!("x is {}", x),
}

// ----------
let numbers = (2, 4, 8, 16, 32);

match numbers {
    // (.., second, ..) 这种模糊的匹配会失败
    (first, .., last) =&gt; {
        println!("Some numbers: {}, {}", first, last);
    },
}
</code></pre>

<h4>match guard</h4>

<pre><code class="rust">// 指定于 match 分支模式之后的额外 if 条件，它也必须被满足才能选择此分支
let x = Some(5);
let y = 10;

match x {
    Some(50) =&gt; println!("Got 50"),
    // 匹配 Some(n), 然后绑定 n, 如果 n == y, 匹配成功
    // 该例中, 匹配 Some(n) 成功，但是由于 n != y，所以进入 _ 分支
    Some(n) if n == y =&gt; println!("Matched, n = {}", n),
    _ =&gt; println!("Default case, x = {:?}", x), // 最终匹配到这个分支
}
</code></pre>

<pre><code class="rust">let x = 4;
let y = false;

match x {
    // 匹配 4, 5, 6; 并且 y == true
    4 | 5 | 6 if y =&gt; println!("yes"),
    _ =&gt; println!("no"), // 最终匹配到这个分支
}
</code></pre>

<h4>@ 绑定</h4>

<pre><code class="rust">// @ 符号让我们可以创建一个变量，该变量可以在测试某个值是否与模式匹配的同时保存该值
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    // 要求 id 的值在 3~7 范围内，同时使用 @ 将匹配到的值存储在 id_variable 变量中
    Message::Hello { id: id_variable @ 3..=7 } =&gt; {
        println!("Found an id in range: {}", id_variable) // 
    },
    // 这里由于 id 匹配的是一个范围，其可能是 10 11 12, 没有具体的值，所以即使匹配到了也无法绑定
    // 如果匹配到该子句了，想在子句内使用具体匹配到的值，也得 { id: id_variable @ 10..=12 }
    Message::Hello { id: 10..=12 } =&gt; {
        println!("Found an id in another range")
    },
    // 该子句指定了一个没有范围的比例，所以如果匹配到这行，id 可以绑定具体的值
    Message::Hello { id } =&gt; {
        println!("Found some other id: {}", id)
    },
}
// Found an id in range: 5
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rust - Concurrency]]></title>
    <link href="http://away0x.github.io/blog/2021/10/12/rust-concurrency/"/>
    <updated>2021-10-12T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2021/10/12/rust-concurrency</id>
    <content type="html"><![CDATA[<ul>
<li>Concurrent 并发: 程序的不同部分之间可以独立的运行</li>
<li>Parallel 并行: 程序的不同部分同时运行</li>
</ul>


<h2>线程</h2>

<ul>
<li>通过 <code>thread::spawn</code> 创建线程

<ul>
<li>参数为一个闭包, 闭包里面是在新线程中运行的代码</li>
</ul>
</li>
</ul>


<pre><code class="rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
    // 当主线程结束时，新线程也会结束，而不管子线程是否执行完毕
    // 可以使用 join 等待子线程执行完毕 (会堵塞, 直到线程执行完毕)
    handle.join().unwrap();
}
</code></pre>

<ul>
<li>move 闭包常与 spawn 一起使用, 它允许我们在一个线程中使用另一个线程的数据</li>
</ul>


<pre><code class="rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];
    // 将 v 的所有权移动到了线程中, 这样线程中就可以安全的使用 v 变量了
    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
</code></pre>

<h2>消息传递</h2>

<ul>
<li>线程 (或 Actor) 通过彼此发送消息(数据)来进行通信

<ul>
<li><strong>不用用共享内存来通信, 要用通信来共享内存</strong></li>
</ul>
</li>
<li>Rust 中使用 <code>Channel</code> 来实现消息传递

<ul>
<li>Channel 包含发送端和接收端, 如果这两端中任意一端被丢弃了, 那么 Channel 就关闭了</li>
</ul>
</li>
<li>使用 <code>mpsc::channel</code> 来创建 Channel

<ul>
<li>mpsc (multiple producer, single consumer): 多个生产者, 一个消费者</li>
</ul>
</li>
<li>发送端:

<ul>
<li><code>send</code> 方法:

<ul>
<li>参数: 要发送的数据</li>
<li>返回值: <code>Result&lt;T, E&gt;</code>, 如果有问题(如接收端已经被丢弃), 就会返回一个 Err</li>
</ul>
</li>
</ul>
</li>
<li>接收端:

<ul>
<li><code>recv</code> 方法 (堵塞当前线程运行, 直到 Channel 中有值传送过来)

<ul>
<li>一但有值收到, 就会返回 <code>Result&lt;T, E&gt;</code></li>
<li>当发送端关闭, 就会收到一个错误</li>
</ul>
</li>
<li><code>try_recv</code> 方法 (不会堵塞)

<ul>
<li>立即返回 <code>Result&lt;T, E&gt;</code>, 有数据到达会返回 Ok, 否则返回 Err</li>
<li>通常会使用循环调用来检查该函数的结果</li>
</ul>
</li>
</ul>
</li>
</ul>


<pre><code class="rust">use std::thread;
use std::sync::mpsc;

fn main() {
    // tx: 发送端
    // rx: 接收端
    let (tx, rx) = mpsc::channel();

    // move: 使新的线程拥有了 tx 发送端的所有权了
    thread::spawn(move || {
        let val = String::from("hi");
        // 这里 send 之后, val 的所有权会被转移给接收者
        tx.send(val).unwrap(); // 发送数据
        // val 不可用了
    });

    // 接收数据 (阻塞主线程执行直到从通道中接收一个值)
    // 当通道发送端关闭，recv 会返回一个错误表明不会再有新的值到来了
    // 还有个方法 try_recv, 其不会堵塞则是立即返回 Result, Ok 表示有值, Err 表示值还没到来
    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
</code></pre>

<pre><code class="rust">// 发送多个值
use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1)); // 暂停 1s
        }
    });

    // 可把接受者 rx 当作迭代器使用, 每过 1s 会接收到一个值
    for received in rx {
        println!("Got: {}", received);
    }
}
</code></pre>

<pre><code class="rust">// 通过克隆发送者来创建多个生产者

// ...
let (tx, rx) = mpsc::channel();

let tx1 = tx.clone();
thread::spawn(move || {
    let vals = vec![
        String::from("hi"),
        String::from("from"),
    ];

    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

thread::spawn(move || {
    let vals = vec![
        String::from("more"),
        String::from("messages"),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

// 会接收到 tx1 和 tx 两个发送端发送的数据
for received in rx {
    println!("Got: {}", received);
}
// ...
</code></pre>

<h2>共享状态</h2>

<ul>
<li>Rust 支持通过共享状态来实现并发

<ul>
<li>Channel 类似单所有权: 一旦值的所有权转移至 Channel, 就无法使用它了</li>
<li>共享内存的并发类似多所有权: 多个线程可以同时访问同一块内存</li>
</ul>
</li>
<li>使用 <code>Mutex</code> (mutual exclusion 互斥锁) 来保证每次只允许一个线程来访问数据

<ul>
<li>想要访问数据, 线程必须首先获取互斥锁 (lock)

<ul>
<li>lock: 是一种数据结构, 是 mutex 的一部分, 它能跟踪谁对数据拥有独占访问权</li>
</ul>
</li>
<li>mutex 通常被描述为: 通过锁定系统来保护它所持有的数据</li>
</ul>
</li>
<li><strong>Mutex 的两条规则</strong>

<ol>
<li>在使用数据之前, 必须尝试获取锁(lock)</li>
<li>使用完 mutex 所保护的数据, 必须对数据进行解锁, 以便其他线程可以获取锁</li>
</ol>
</li>
<li>Mutex 的 API:

<ul>
<li>通过 <code>Mutex::new(数据)</code> 来创建 <code>Mutex&lt;T&gt;</code>

<ul>
<li><code>Mutex&lt;T&gt;</code> 是一个智能指针</li>
</ul>
</li>
<li>访问数据前, 通过 lock 方法来获取锁

<ul>
<li>会堵塞当前线程</li>
<li>lock 可能会失败</li>
<li>返回的是 MutexGuard (智能指针, 实现了 Deref 和 Drop)</li>
</ul>
</li>
</ul>
</li>
</ul>


<pre><code class="rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    } // mutex 使用了 Drop trait, 所以这里会自动 unlock

    println!("m = {:?}", m);
}
</code></pre>

<ul>
<li>原子引用计数 <code>Arc&lt;T&gt;</code> (A: atomic)

<ul>
<li>类似 <code>Rc&lt;T&gt;</code> (Rc 线程不安全) 并可以安全的用于并发环境的类型, 和 <code>Rc&lt;T&gt;</code> 有着相同的 API</li>
</ul>
</li>
</ul>


<pre><code class="rust">// 多线程共享 mutex
use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        // 利用 Arc 实现多线程之间共享所有权
        // 不使用 Arc 的话, 在第一次循环时, counter 的所有权就会被移动到线程中, 第二次循环就会报错 (不能将 counter 锁的所有权移动到多个线程中)
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            // 线程中获取 lock, 并修改值
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    // 等所有线程都执行完毕后再往下执行
    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
</code></pre>

<h3><code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> 与 <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code> 的相似性</h3>

<ul>
<li><code>Mutex&lt;T&gt;</code> 提供了内部可变性, 和 Cell 家族一样

<ul>
<li>使用 <code>RefCell&lt;T&gt;</code> 来改变 <code>Rc&lt;T&gt;</code> 里面的内容</li>
<li>使用 <code>Mutex&lt;T&gt;</code> 来改变 <code>Arc&lt;T&gt;</code> 里面的内容</li>
<li>注意: <code>Mutex&lt;T&gt;</code> 有死锁风险</li>
</ul>
</li>
</ul>


<h2>Send &amp; Sync</h2>

<h3>Send Trait</h3>

<ul>
<li><code>std::marker::Send</code>: 允许线程间转移所有权</li>
<li>实现 Send Trait 的类型就可以在线程间转移所有权

<ul>
<li>Rust 中几乎所有的类型都实现了 Send</li>
<li><code>Rc&lt;T&gt;</code> 没有实现 Send, 它只用于单线程场景</li>
</ul>
</li>
<li>任何完全由 Send 类型组成的类型也是 Send</li>
<li>除了原始指针之外, 几乎所有的基础类型都是 Send</li>
</ul>


<h3>Sync Trait</h3>

<ul>
<li><code>std::marker::Sync</code>: 允许从多线程访问</li>
<li>实现 Sync Trait 的类型可以安全的被多个线程引用

<ul>
<li>即: <strong>如果 <code>T</code> 是 Sync, 那么 <code>&amp;T</code> 就是 Send</strong>, <code>&amp;T</code> 可以被安全的送往另外一个线程</li>
</ul>
</li>
<li>任何完全由 Sync 类型组成的类型也是 Sync</li>
<li>基础类型都是 Sync</li>
<li><code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code>, <code>Cell&lt;T&gt;</code> 家族都不是 Sync 的</li>
<li><code>Mutex&lt;T&gt;</code> 是 Sync 的</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rust - Smart Pointers]]></title>
    <link href="http://away0x.github.io/blog/2021/10/11/rust-smart-pointers/"/>
    <updated>2021-10-11T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2021/10/11/rust-smart-pointers</id>
    <content type="html"><![CDATA[<ul>
<li>指针: 一个变量在内存中包含的是一个地址 (指向其他数据)</li>
<li>Rust 中最常见的指针就是 &ldquo;引用&rdquo;

<ul>
<li>使用 <code>&amp;</code></li>
<li>借用它指向的值</li>
<li>没有其余开销</li>
<li>最常见的指针类型</li>
</ul>
</li>
<li><strong>智能指针:</strong>

<ul>
<li>行为和指针类似</li>
<li>有额外的元数据和功能</li>
</ul>
</li>
<li><strong>引用</strong>和<strong>智能指针</strong>的不同

<ul>
<li>引用: 只借用数据</li>
<li>智能指针: 很多时候都拥有它所指向的数据</li>
</ul>
</li>
<li>常用的智能指针类型:

<ul>
<li><code>Box&lt;T&gt;</code>: 在 heap 内存上分配值</li>
<li><code>Rc&lt;T&gt;</code>: 启用多重所有权的引用计数类型</li>
<li><code>Ref&lt;T&gt;</code>、<code>RefMut&lt;T&gt;</code>: 通过 <code>RefCell&lt;T&gt;</code> 访问，在运行时而不是编译时强制借用规则的类型</li>
</ul>
</li>
<li><code>String</code> 和 <code>Vec&lt;T&gt;</code> 就是智能指针

<ul>
<li>它们都拥有一片内存区域，且运行用户对其操作</li>
<li>拥有元数据 (例如容量等)</li>
<li>提供额外的功能或保障 (String 保障其数据时合法的 UTF-8 编码)</li>
</ul>
</li>
<li><strong>通常使用 struct 实现，并且实现了: <code>Deref</code> 和 <code>Drop</code> 两个 Trait</strong>

<ul>
<li>Deref trait: 允许智能指针 struct 的实例像引用一样使用</li>
<li>Drop trait: 允许你自动移当智能指针实例走出作用域时的代码</li>
</ul>
</li>
<li><strong>内部可变模式 (interior mutability pattern):</strong> 不可变类型暴露出可修改其内部值的 API</li>
</ul>


<h2><code>Box&lt;T&gt;</code> 类型</h2>

<ul>
<li>其是最简单的智能指针:

<ul>
<li>允许你在 Heap 上存储数据 (而不是 stack)</li>
<li>stack 上是指向 Heap 数据的指针</li>
<li>没有性能开销</li>
<li>没有其他额外功能</li>
<li>适用于 &ldquo;间接&rdquo; 存储的场景</li>
<li>实现了 <code>Deref</code> 和 <code>Drop</code> 两个 Trait</li>
</ul>
</li>
<li>使用场景:

<ol>
<li>在编译时，某类型的大小无法确定。但使用该类型时，上下文却需要知道它的确切大小

<ul>
<li><code>Box&lt;T&gt;</code> 是一个指针, Rust 知道它需要多少空间 (指针的大小不会基于它指向的数据的大小变化而变化)</li>
<li><code>Box&lt;T&gt;</code></li>
</ul>
</li>
<li>当有大量数据，想移交所有权，但需要确保在操作时数据不会被复制</li>
<li>使用某个值时，你只关心它是否实现了特定的 Trait，而不关心它的具体类型</li>
</ol>
</li>
</ul>


<pre><code class="rust">fn main() {
    let a = Box::new(5); // 整数 5 存储在 heap 上了
    println("a = {}", a); // "a = 5"
} // a 被释放了 (会释放其存储在 stack 上的指针，以及存储在 heap 上的数据)
</code></pre>

<h3>Cons List (递归类型)</h3>

<ul>
<li>在编译时，Rust 需要知道一个类型所占的空间大小</li>
<li>而递归类型的大小无法在编译时确定, 但 Box 类型的大小确定，在递归类型中使用 Box 就可解决上述问题</li>
<li>这种类型 <code>Cons List</code> 是来自 Lisp 的一种数据结构

<ul>
<li>Cons List 里每个成员由两个元素组成

<ol>
<li>当前项的值</li>
<li>下一个元素</li>
</ol>
</li>
<li>Cons List 里最后一个成员只包含一个 Nil 值，没有下一个元素</li>
</ul>
</li>
</ul>


<pre><code class="rust">// 使用 Rust 实现 Cons List
use crate::List::{Cons, Nil};

enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

fn main() {
    // Box&lt;T&gt; 提供了 "间接" 存储和 heap 内存分配的方式
    let list = Cons(1, 
        Box::new(Cons(2, 
            Box::new(Cons(3, 
                Box::new(Nil))))));

    println!("{:?}", list); // Cons(1, Cons(2, Cons(3, Nil)))
}
</code></pre>

<h2>Deref Trait</h2>

<ul>
<li>实现该 Trait 可使我们能<strong>自定义解引用运算符 <code>*</code> 的行为</strong></li>
<li>通过实现 Deref，智能指针可<strong>像常规引用一样来处理</strong></li>
<li>解引用运算符 <code>*</code>

<ul>
<li>常规的引用也是一种指针</li>
</ul>
</li>
</ul>


<pre><code class="rust">let x = 5;
let y = &amp;x;

assert_eq!(5, x); // ok
assert_eq!(5, *y); // ok

// 使用 Box&lt;T&gt; 替代上面的引用
let y = Box::new(x);
assert_eq!(5, *y); // ok
</code></pre>

<pre><code class="rust">// 自定义智能指针
struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}

impl &lt;T&gt;std::ops::Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}

fn main() {
    let x = 5;
    let y = MyBox::new(x);
    assert_eq!(5, *y); // ok 
    // *y 相当于 *(y.deref())
}
</code></pre>

<h3>Deref Coercion</h3>

<ul>
<li>Deref Coercion (函数和方法的隐式解引用转化) 是为函数和方法提供的一种便捷特性</li>
<li>假设 <code>T</code> 实现了 Deref trait

<ul>
<li>Deref Coercion 可以把 <code>T</code> 的引用转化为 <code>T</code> 经过 Deref 操作后生成的引用</li>
</ul>
</li>
<li>当把某类型的引用传递给函数或方法时，但它的类型与定义的参数类型不匹配:

<ul>
<li>Deref Coercion 就会自动发生</li>
<li>编译器会对 deref 进行一系列调用，来把它转为所需的参数类型 (在编译时完成，没有额外的性能开销)</li>
</ul>
</li>
</ul>


<pre><code class="rust">fn hello(name: &amp;str) {
    println!("Hello, {}", name);
}

fn main() {
    let m = MyBox::new(String::from("world"));
    // &amp;m: &amp;MyBox&lt;String&gt;
    // - 由于 MyBox 实现了 deref trait，所以编译器可以把 &amp;MyBox&lt;String&gt; 转化为 &amp;String
    // - 由于标准库中 String 也实现了 deref trait，调用 deref 方法返回一个 &amp;str 类型
    // - 所以 &amp;m 可以作为参数传入，满足 &amp;str 的参数类型要求
    hello(&amp;m);
    // 如果没有实现 deref trait，则这里得这样调用: hello(&amp;(*m)[..])
}
</code></pre>

<h3>解引用与可变性</h3>

<ul>
<li>可使用 <code>DerefMut Trait</code> 重载可变引用 <code>*</code> 运算符</li>
<li>在类型和 trait 在下列三种情况发生时，Rust 会执行 Deref Coercion:

<ol>
<li>当 <code>T: Deref&lt;Target=U&gt;</code>，允许 <code>&amp;T</code> 转换为 <code>&amp;U</code></li>
<li>当 <code>T: DerefMut&lt;Target=U&gt;</code>，允许 <code>&amp;mut T</code> 转换为 <code>&amp;mut U</code></li>
<li>当 <code>T: Deref&lt;Target=U&gt;</code>，允许 <code>&amp;mut T</code> 转换为 <code>&amp;U</code></li>
</ol>
</li>
</ul>


<h2>Drop Trait</h2>

<ul>
<li>类似实现 <code>Drop Trait</code>，可以让我们自定义<strong>当值将要离开作用域时发生的动作</strong>

<ul>
<li>例如: 文件、网络资源释放等</li>
</ul>
</li>
<li>任何类型都可以实现 Drop Trait, 该 trait 在 prelude 里面</li>
</ul>


<pre><code class="rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("drop");
    }
}

fn main() {
    let a = CustomSmartPointer { data: String::from("hello") };
} // "drop"
</code></pre>

<ul>
<li>Rust 不允许手动调用 Drop trait 的 drop 方法

<ul>
<li>但可以调用标准库的 <code>std::mem::drop</code> 函数，来提前 drop 值</li>
</ul>
</li>
</ul>


<h2><code>Rc&lt;T&gt;</code> 引用计数智能指针</h2>

<ul>
<li>有时, 一个值会有多个所有者, 为了<strong>支持这种多重所有权的情况</strong>, Rust 实现了 <code>Rc&lt;T&gt;</code>

<ul>
<li>RC: reference counting (引用计数)</li>
<li>该类型会在实例内部维护一个用于记录值引用次数的计数器, 用于判断这个值是否被使用 (可以追踪值的所有引用)</li>
<li>0 个引用: 该值可以被清理掉</li>
<li><code>Rc&lt;T&gt;</code> 通过不可变引用, 使我们可以在程序不同部分共享<strong>只读</strong>数据</li>
</ul>
</li>
<li>使用场景: 需要在 heap 上分配数据, 这些数据被程序的多个部分读取(只读), 但在编译时无法确定哪个部分最后使用完这些数据</li>
<li><code>Rc&lt;T&gt;</code> 只能用于单线程场景, 多线程场景可以使用 <code>Arc&lt;T&gt;</code>

<ul>
<li>Rc 为了性能使用的不是线程安全的引用计数器</li>
<li>Arc 内部引用计数使用了 atomic usize, 线程安全</li>
</ul>
</li>
<li><code>Rc::clone(&amp;a) 函数</code>: 会增加引用计数</li>
<li><code>Rc::strong_count(&amp;a)</code>: 获得引用计数

<ul>
<li>还有 <code>Rc::weak_count</code> 函数</li>
</ul>
</li>
</ul>


<pre><code class="rust">use std::rc::Rc;

fn main() {
    let a = Rc::new(1);
    // 对一个 Rc 结构进行 clone()，不会将其内部的数据复制，只会增加引用计数
    let b = a.clone();
    let c = a.clone();

    // 作用域有三个 Rc(a, b, c), 它们共同指向堆上相同的数据, 即堆上的数据有 3 个共享的所有者
    // 而当一个 Rc 结构离开作用域被 drop() 时，也只会减少其引用计数，直到引用计数为零，才会真正清除对应的内存
}
</code></pre>

<pre><code class="rust">// 两个 List 共享另一个 List 的所有权
enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    // b, c 共享 a 的所有权
    let b = Cons(3, Rc::clone(&amp;a)); // 引用计数+1
    {
        let c = Cons(4, Rc::clone(&amp;a)); // 引用计数+1
    } // c 离开作用域了, 引用计数自动 -1
    // a.clone() 该方法会进行深度的 copy; Rc::clone 只会增加引用计数, 不会执行数据的深度 copy
    // a 在引用计数清零的时候才会被回收
}
</code></pre>

<h2><code>RefCell&lt;T&gt;</code></h2>

<ul>
<li>内部可变性: 是 Rust 的设计模式之一, 它允许你在只持有不可变引用的前提下对数据进行修改

<ul>
<li>数据结构中使用了 unsafe 代码来绕过 Rust 正常的可变性和借用规则</li>
</ul>
</li>
<li>与 <code>Rc&lt;T&gt;</code> 不同, <code>RefCell&lt;T&gt;</code> 类型代表了其持有数据的唯一所有权

<ul>
<li>Rc 是个只读的引用计数器, 无法拿到 Rc 结构内部数据的可变引用</li>
</ul>
</li>
<li><code>RefCell&lt;T&gt;</code> 和 <code>Box&lt;T&gt;</code> 的区别

<ul>
<li><code>RefCell&lt;T&gt;</code>: 只会在运行时检查借用规则, 运行时不满足借用规则会触发 panic</li>
<li><code>Box&lt;T&gt;</code>: 在编译阶段强制代码遵守借用规则, 不满足规则会出现错误</li>
</ul>
</li>
<li>借用规则在不同阶段进行检查的比较:

<ol>
<li>编译阶段:

<ol>
<li>尽早暴露问题</li>
<li>没有任何运行时开销</li>
<li>对大多数场景是最佳选择</li>
<li>是 Rust 的默认行为</li>
</ol>
</li>
<li>运行时:

<ol>
<li>问题暴露延后, 甚至到生产环境</li>
<li>由于使用了借用计数, 会产生些许性能损失</li>
<li>实现某些特定的内存安全场景 (不可变环境中修改自身数据)</li>
</ol>
</li>
</ol>
</li>
<li>与 <code>Rc&lt;T&gt;</code> 相似, 只能用于<strong>单线程</strong>场景

<ul>
<li>多线程场景使用需要使用 Mutex(互斥量) 和 RwLock(读写锁)</li>
<li>例如: <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 在多线程场景下可替换为 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 或 <code>Arc&lt;RwLock&lt;T&gt;&gt;</code></li>
</ul>
</li>
</ul>


<h3>内部可变性: 可变的借用一个不可变的值</h3>

<ul>
<li>外部可变性: 使用 <code>let mut</code>, <code>&amp;mut</code>

<ul>
<li>所有权检查: 编译时, 如果不符合规则, 产生编译错误</li>
</ul>
</li>
<li>内部可变性: 使用 <code>Cell</code>, <code>RefCell</code>

<ul>
<li>所有权检查: 运行时, 如果不符合规则, panic</li>
</ul>
</li>
</ul>


<pre><code class="rust">fn main() {
    let x = 5;
    let y = &amp;mut x; // 报错, 无法可变的借用一个不可变的值
    // 有时会需要有这一种场景, 值在外部是不可变的, 但是在方法内部需要可以修改这个值
    // 可以使用 RefCell 来实现这种内部可变性
}
</code></pre>

<h3>使用 <code>RefCell&lt;T&gt;</code></h3>

<ul>
<li><code>RefCell&lt;T&gt;</code> 的方法

<ul>
<li><code>borrow</code> 方法: 返回 <code>Ref&lt;T&gt;</code>, 它实现了 Deref trait</li>
<li><code>borrow_mut</code> 方法: 返回 <code>RefMut&lt;T&gt;</code>, 它实现了 Deref trait</li>
</ul>
</li>
<li><code>RefCell&lt;T&gt;</code> 会记录当前存在多少个活跃的 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code> 智能指针

<ul>
<li>每次调用 borrow: 不可变借用计数 +1</li>
<li>任何一个 <code>Ref&lt;T&gt;</code> 的值离开作用域被释放时: 不可变借用计数 -1</li>
<li>每次调用 borrow_mut: 可变借用计数 +1</li>
<li>任何一个 <code>RefMut&lt;T&gt;</code> 的值离开作用域被释放时: 可变借用计数 -1</li>
</ul>
</li>
<li>Rust 通过以上计数规则来维护借用的检查规则

<ul>
<li>任何一个给定时间里, 只允许拥有多个不可变借用活一个可变借用</li>
</ul>
</li>
</ul>


<pre><code class="rust">use std::cell::RefCell;

fn main() {
    let data = RefCell::new(1);
    // 在同一个作用域下，我们不能同时有活跃的可变借用和不可变借用
    // 通过这对花括号，我们明确地缩小了可变借用的生命周期，不至于和后续的不可变借用冲突
    { 
        // 获得 RefCell 内部数据的可变借用
        let mut v = data.borrow_mut();
        *v += 1;
    }
    println!("data: {:?}", data.borrow()); // data: 2
}
</code></pre>

<h3>如何选择 <code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code>、<code>RefCell&lt;T&gt;</code></h3>

<table>
<thead>
<tr>
<th> </th>
<th> <code>Box&lt;T&gt;</code> </th>
<th> <code>Rc&lt;T&gt;</code> </th>
<th> <code>RefCell&lt;T&gt;</code> </th>
</tr>
</thead>
<tbody>
<tr>
<td> 同一数据的所有者 </td>
<td> 一个 </td>
<td> 多个 </td>
<td> 一个 </td>
</tr>
<tr>
<td> 可变性、借用检查 </td>
<td> 可变、不可变借用 (编译时检查) </td>
<td> 不可变借用 (编译时检查) </td>
<td> 可变、不可变借用 (运行时检查) </td>
</tr>
</tbody>
</table>


<h3>结合 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 来拥有多个可变数据所有者</h3>

<pre><code class="rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}
</code></pre>

<h3>其他可实现内部可变性的类型</h3>

<ul>
<li><code>Cell&lt;T&gt;</code>: 通过复制来访问数据</li>
<li><code>Mutex&lt;T&gt;</code>: 用于实现跨线程情形下的内部可变性模式</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rust - Closure, Function Pointer, Iterator]]></title>
    <link href="http://away0x.github.io/blog/2021/10/10/rust-closure-function-iterator/"/>
    <updated>2021-10-10T08:00:00+08:00</updated>
    <id>http://away0x.github.io/blog/2021/10/10/rust-closure-function-iterator</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#Closure">Closure</a></li>
<li><a href="#FunctionPointer">Function Pointer</a></li>
<li><a href="#Iterator">Iterator</a></li>
</ul>


<h2><h2 id="Closure">Closure</h2></h2>

<ul>
<li>闭包: 可以捕获其所在环境的匿名函数

<ul>
<li>可以保存为变量、可以作为参数</li>
<li>可在一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算</li>
<li>可以从其定义的作用域捕获值</li>
</ul>
</li>
<li>闭包不要求像函数那样在参数和返回值上标注类型，函数需要是因为他们可能会暴露给外部使用, 而闭包则存储在变量中，不暴露给外部使用

<ul>
<li>闭包像变量定义一样可从上下文环境中推断出类型</li>
</ul>
</li>
</ul>


<pre><code class="rust">// 由于 rust 可从上下文推断类型，所以该例中参数类型可省略
let func = |n1, n2| {
    println!("{}, {}", n1, n2);
};

let func2 = |n: u32| {
    println!("{}", n)
};

let func3 = |n: u32| -&gt; u32 {
    n
};

let func4 = |n| n + 1; // 只有一行，可省略 {}

func(1, 2);
func2(1);
let l = func3(3);
println!("{}", l);
let l = func4(4);
println!("{}", l);
</code></pre>

<h3>让 struct 持有闭包</h3>

<ul>
<li>每个闭包实例都有自己唯一的匿名类型，即使两个闭包的签名完全一样</li>
</ul>


<pre><code class="rust">struct Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    calculation: T, // 存储闭包，用于计算值
    value: Option&lt;u32&gt;,
}

impl&lt;T&gt; Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher { calculation, value: None }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        // 有值表示闭包已执行过，直接返回值
        match self.value {
            Some(v) =&gt; v,
            None =&gt; { // 没值，则调用闭包计算值
                let v = (self.calculation)(arg); // 调用闭包
                self.value = Some(v);
                v
            }
        }
    }
}
</code></pre>

<h3>闭包会捕获其所在的环境</h3>

<ul>
<li>闭包可以访问定义它的作用域内的变量，而普通函数则不能

<ul>
<li>这会产生额外的开销</li>
</ul>
</li>
</ul>


<pre><code class="rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x; // 可以执行，闭包内部可以获取到执行环境的变量
    // fn equal_to_x(z: i32) -&gt; bool { z == x } // 报错，函数获取不到执行环境的变量

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre>

<h3>Fn Trait</h3>

<ul>
<li>由标准库提供，所有的闭包都至少实现了以下 trait 之一 (根据闭包捕获环境的方式分类)

<ul>
<li><strong>Fn:</strong> 取得捕获到的变量的不可变借用</li>
<li><strong>FnMut:</strong> 取得捕获到的变量的可变借用</li>
<li><strong>FnOnce:</strong> 会取得捕获到的变量的所有权，只能被调用一次</li>
</ul>
</li>
<li>创建闭包时，通过闭包对环境值的使用，Rust 可推断出具体使用哪个 trait

<ul>
<li>所有闭包都实现了 FnOnce</li>
<li>没有移动捕获变量的闭包实现了 FnMut</li>
<li>无需可变访问捕获变量的闭包实现了 Fn</li>
</ul>
</li>
</ul>


<h3>move 关键字</h3>

<ul>
<li>在参数列表前使用 move 关键字，可以强制闭包取得它所使用的环境值的所有权

<ul>
<li>当将闭包传递给新线程以移动数据使其归新线程所有时，该技术很有用</li>
</ul>
</li>
</ul>


<pre><code class="rust">fn main() {
    let x = vec![1, 2, 3];

    // x 所有权移动到了闭包内
    let equal_to_x = move |z| z == x;
    println!("can't use x here: {:?}", x); // 报错，x 所有权转移了，不可用

    let y = vec![1, 2, 3];
    assert!(equal_to_x(y));
}
</code></pre>

<h3>返回闭包</h3>

<ul>
<li>闭包表现为 trait，这意味着不能直接返回闭包。对于大部分需要返回 trait 的情况，可以使用实现了期望返回的 trait 的具体类型来替代函数的返回值</li>
</ul>


<pre><code class="rust">// 报错
// trait 不是一个可返回的具体类型
fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
    |x| x + 1
}

// ok
// 标明返回值是一个实现了 Fn(i32) -&gt; i32 trait 的类型
fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
</code></pre>

<h2><h2 id="FunctionPointer">Function Pointer</h2></h2>

<ul>
<li>可以将函数传递给其他函数</li>
<li>函数在传递过程中会被强制转换成 <strong>fn</strong> 类型</li>
</ul>


<pre><code class="rust">fn add_one(x: i32) -&gt; i32 { x + 1 }

// f: 函数指针
fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5); // 12
}
</code></pre>

<h3>函数指针与闭包的不同:</h3>

<pre><code>- `fn` 是一个类型, 不是一个 trait (这和闭包不同)
    - 可以直接指定 `fn` 为参数类型, 不用声明一个 `Fn Trait` 为约束的泛型参数
</code></pre>

<ul>
<li>函数指针实现了全部三种闭包 Trait (Fn, FnMut, FnOnce)

<ul>
<li>所以总时可以把函数指针用作参数传递给一个解释闭包的函数</li>
<li>所以倾向于搭配闭包 trait 的泛型来编写函数: <strong>可以同时接收闭包和普通函数</strong></li>
</ul>
</li>
<li>某些情景下, 只想接收 fn 而不接收闭包

<ul>
<li>与外部不支持闭包的代码交互: 如 C 函数</li>
</ul>
</li>
</ul>


<pre><code class="rust">// 使用闭包
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(|i| i.to_string()) // 闭包
    .collect();

// 使用函数指针
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(ToString::to_string) // 函数指针
    .collect();
</code></pre>

<pre><code class="rust">enum Status {
    Value(u32),
    Stop,
}

// let v = Status::Value(3)
// - 这里的构造器是被实现为返回由参数构造的实例的函数
// - 所以下例可以将  Status::Value 作为函数指针使用

let list_of_statuses: Vec&lt;Status&gt; =
    (0u32..20)
    .map(Status::Value)
    .collect();
</code></pre>

<h2><h2 id="Iterator">Iterator</h2></h2>

<ul>
<li>Rust 的迭代器是懒惰的，除非调用消费迭代器的方法，否则迭代器本身没有任何效果</li>
<li>Rust 的迭代器是零成本抽象，使用时不用担心性能问题</li>
</ul>


<pre><code class="rust">let v1 = vec![1, 2, 3];
for val in v1.iter() {
    println!("{}", val);
}
</code></pre>

<h3>Iterator Trait</h3>

<ul>
<li>所有的迭代器都实现了 Iterator Trait, 其定义于标准库</li>
<li>Iterator Trait 仅要求实现 next 方法

<ul>
<li>next: 每次返回迭代器中的一项, 返回结果包裹在 Some 里, 迭代结束返回 None</li>
</ul>
</li>
</ul>


<pre><code class="rust">// 大致定义如下
pub trait Iterator {
    type item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::item&gt;;
}
</code></pre>

<pre><code class="rust">// 在在迭代器类型上调用 next 方法
#[cfg(test)]
mod tests {
    #[test]
    fn test_iter() {
        let v1 = vec![1, 2, 3];
        let mut v1iter = v1.iter();

        assert_eq!(v1iter.next(), Some(&amp;1));
        assert_eq!(v1iter.next(), Some(&amp;2));
        assert_eq!(v1iter.next(), Some(&amp;3));
    }
}
</code></pre>

<ul>
<li><code>.iter()</code>: 在不可变引用上创建迭代器</li>
<li><code>.iter_mut</code>: 迭代可变的引用</li>
<li><code>.into_iter()</code>: 获取所有权并返回拥有所有权的迭代器</li>
</ul>


<h4>消耗迭代器的方法</h4>

<ul>
<li>在标准库中, Iterator Trait 有一些默认实现的方法</li>
<li>其中有一些方法会调用 next 方法 (这些调用 next 的方法叫做 <strong>消耗型适配器</strong>)

<ul>
<li>因为调用它们会把迭代器耗尽, 例如 <code>sum</code>, <code>collect</code> 方法</li>
</ul>
</li>
<li><code>sum</code>: 对迭代器进行求和</li>
<li><code>collect</code>: 把结果收集到一个集合类型中</li>
</ul>


<pre><code class="rust">// sum
let v1 = vec![1, 2, 3];
let v1_iter = v1.iter();
let total: i32 = v1_iter.sum();

assert_eq!(total, 6);
</code></pre>

<h4>产生其他迭代器的方法</h4>

<ul>
<li>会把迭代器转换为不同种类的迭代器 (称为 <strong>迭代器适配器</strong>)</li>
<li>可通过链式调用使用多个迭代器适配器来执行复杂的操作, 例如 <code>map</code> 方法</li>
<li><code>map</code>、<code>filter</code> &hellip;</li>
</ul>


<pre><code class="rust">let v1 = vec![1, 2, 3];
let v2: Vec&lt;_&gt; = v1.iter()
    .map(|x| x + 1) // 由于迭代器是惰性的，所以在这一行，并不会执行 +1 的操作
    .collect(); // 执行了这个消耗型适配器, 此时才会开始执行迭代器里面的操作，进行消耗

assert_eq!(v2, vec![2, 3, 4]);
</code></pre>

<h3>迭代器配合闭包使用</h3>

<pre><code class="rust">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|x| x.size == shoe_size).collect()
}

fn main() {
    let shoes = vec![
        Shoe { size: 10, style: String::from("sneaker") },
        Shoe { size: 13, style: String::from("sandal") },
        Shoe { size: 10, style: String::from("boot") },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from("sneaker") },
            Shoe { size: 10, style: String::from("boot") },
        ]
    );
}
</code></pre>

<h3>自定义迭代器</h3>

<p>impl Iterator trait 即可得到迭代器的功能</p>

<pre><code class="rust">struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32; // 迭代器返回 u32 类型数据

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;
        if self.count &lt; 6 { Some(self.count) } else { None }
    }
}

fn main() {
    let mut counter = Counter::new();

    // next
    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);

    // 调用迭代器的其他方法
    let sum: u32 = Counter::new() // 1 迭代到 5
        // 整合两个迭代器, 每一项为 tuple，tuple.0 为第一个迭代器的元素, tuple.1 为第二个迭代器的元素
        // 第二个迭代器以第二次迭代为起始 (2 迭代到 5)
        .zip(Counter::new().skip(1))
        .map(|(a, b)| a * b)
        .filter(|x| x % 3 == 0)
        .sum();

    assert_eq!(18, sum);
}
</code></pre>

<h3>自己实现迭代器模式</h3>

<pre><code class="rust">trait MyIterator&lt;T: Copy&gt; {
    fn each&lt;F: Fn(T) -&gt; T&gt;(&amp;mut self, f: F);
}
// 性能要比 Rust 的 Iterator 差很多, 这个是一次消费完的, 不是 lazy 模式
impl&lt;T: Copy&gt; MyIterator&lt;T&gt; for Vec&lt;T&gt; {
    fn each&lt;F: Fn(T) -&gt; T&gt;(&amp;mut self, f: F) {
        let mut i = 0;
        while i &lt; self.len() {
            self[i] = f(self[i]);
            i += 1;
        }
    }
}

fn main() {
    let mut v = vec![1, 2, 3];
    v.each(|i| i * 3);
    assert_eq!([3, 6, 9], &amp;v[..3]);
}
</code></pre>

<h3>for 循环和迭代器</h3>

<p>for 是一个语法糖, 其可以用于任何实现了 IntoIterator trait 的数据结构</p>

<pre><code class="rust">let v = vec![1, 2, 3, 4];

for i in v {
    println!("{}", i);
}

// for 循环等价于以下代码
{ // 等价于 for 循环的 scope
    let mut _iterator = v.into_iter();
    loop {
        match _iterator.next() {
            Some(i) =&gt; {
                println!("{}", i);
            }
            None =&gt; break,
        }
    }
}
</code></pre>

<h3>IterTools</h3>

<blockquote><p><a href="https://crates.io/crates/itertools">https://crates.io/crates/itertools</a></p></blockquote>

<p>该工具可用于扩展标准库里面的迭代器, 类似 python 的 itertools</p>
]]></content>
  </entry>
  
</feed>
