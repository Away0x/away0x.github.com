
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Rust - Ownership, Borrowing - Away0x's Blog</title>
  <meta name="author" content="TongWu">

  
  <meta name="description" content="Ownership
Borrowing Ownership 所有权是 Rust 最独特的特性，它让 Rust 无需 GC 就可以保证内存安全 所有程序在运行时都必须管理它们使用计算机内存的方式 有些语言有垃圾收集机制，在程序运行时，它们会不断的寻找不再使用的内存
而有些语言中， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://away0x.github.io/blog/2021/10/02/rust-ownership-borrowing">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Away0x's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!-- <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> -->
  <script src="/javascripts/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/alpine.min.js" defer type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fjalla+One" rel="stylesheet" type="text/css"> -->
<link href="/stylesheets/google-fonts.css" rel="stylesheet" type="text/css">
<!--- MathJax Configuration -->
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">Away0x's Blog</a></h1>
  
    <h2>Coding blogging for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscribe" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 13.310204,73.332654 C 5.967347,73.332654 0,79.322448 0,86.621428 c 0,7.338776 5.967347,13.262246 13.310204,13.262246 7.370408,0 13.328572,-5.92245 13.328572,-13.262246 0,-7.29898 -5.958164,-13.288774 -13.328572,-13.288774 z M 0.01530612,33.978572 V 53.143878 C 12.493878,53.143878 24.229592,58.02347 33.068368,66.865306 41.894898,75.685714 46.767346,87.47449 46.767346,100 h 19.25 C 66.017346,63.592858 36.4,33.979592 0.01530612,33.978572 l 0,0 z M 0.03877552,0 V 19.17449 C 44.54796,19.17551 80.77551,55.437756 80.77551,100 H 100 C 100,44.87653 55.15102,0 0.03877552,0 z"></path></svg></a></li>
  
</ul>
  
  
  
  
  
<ul class="subscribe">
  <li><a href="https://github.com/Away0x" rel="subscribe-github" title="@Away0x on GitHub" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 50,0 C 22.385714,0 0,22.385714 0,50 0,77.614286 22.385714,100 50,100 77.614286,100 100,77.614286 100,50 100,22.385714 77.614286,0 50,0 z m 29.692858,79.692858 c -3.859184,3.859182 -8.351022,6.887754 -13.35,9.00306 -1.27041,0.536736 -2.560204,1.009184 -3.867348,1.415306 v -7.493878 c 0,-3.938774 -1.35102,-6.835714 -4.053062,-8.690816 1.692858,-0.163264 3.24694,-0.390816 4.663266,-0.683672 1.416326,-0.292858 2.913266,-0.716328 4.491838,-1.27041 1.57857,-0.55408 2.994896,-1.213264 4.247958,-1.97755 1.253062,-0.765306 2.458164,-1.758164 3.613266,-2.978572 1.155102,-1.220408 2.12449,-2.604082 2.905102,-4.15 0.780612,-1.545918 1.4,-3.40204 1.855102,-5.566326 0.455102,-2.164286 0.683674,-4.54898 0.683674,-7.153062 0,-5.045918 -1.643878,-9.341836 -4.931634,-12.890816 C 77.44796,33.35 77.285714,29.10204 75.463266,24.512244 l -1.22143,-0.145918 c -0.845918,-0.09796 -2.368366,0.260204 -4.565306,1.07449 -2.196938,0.814286 -4.663264,2.14796 -7.396938,4.004082 -3.87449,-1.07449 -7.893878,-1.611224 -12.061224,-1.611224 -4.19898,0 -8.203062,0.536734 -12.012246,1.611224 -1.72449,-1.17245 -3.361224,-2.139796 -4.907142,-2.905102 C 31.753062,25.77449 30.516326,25.254082 29.587756,24.97653 28.660204,24.7 27.79796,24.528572 27,24.463266 c -0.79796,-0.0653 -1.310204,-0.08062 -1.537756,-0.04898 -0.22755,0.03164 -0.390816,0.0653 -0.487754,0.09796 -1.82347,4.62245 -1.985714,8.87143 -0.487756,12.743878 -3.287754,3.54796 -4.931632,7.844898 -4.931632,12.890816 0,2.604082 0.227552,4.988776 0.683674,7.153062 0.456122,2.164286 1.07449,4.020408 1.855102,5.566326 0.780612,1.545918 1.75,2.929592 2.905102,4.15 1.155102,1.220408 2.360204,2.213266 3.613264,2.978572 1.253062,0.766326 2.669388,1.42449 4.24796,1.97755 1.578572,0.554082 3.07551,0.976532 4.491836,1.27041 1.416328,0.292856 2.970408,0.521428 4.663266,0.683672 -2.669388,1.82347 -4.004082,4.720408 -4.004082,8.690816 v 7.639796 C 36.536734,89.818368 35.083674,89.3 33.656122,88.695918 c -4.99898,-2.115306 -9.490816,-5.143878 -13.35,-9.00306 -3.859184,-3.859184 -6.887754,-8.351022 -9.00306,-13.35 C 9.1163263,61.171428 8.0071428,55.67347 8.0071428,50 c 0,-5.67347 1.1091835,-11.171428 3.2969392,-16.342858 2.115306,-4.998978 5.143878,-9.490816 9.00306,-13.35 3.859184,-3.859182 8.351022,-6.887754 13.35,-9.00306 C 38.828572,9.1163266 44.32653,8.0071428 50,8.0071428 c 5.67347,0 11.171428,1.1091838 16.342858,3.2969392 5,2.115306 9.490816,5.143878 13.35,9.00306 3.859182,3.859184 6.887754,8.351022 9.00306,13.35 2.186736,5.17245 3.295918,10.67041 3.295918,16.342858 0,5.672448 -1.109182,11.171428 -3.296938,16.342858 -2.115306,4.998978 -5.143878,9.490816 -9.00204,13.35 l 0,0 z"></path></svg></a></li>
</ul>
  
  
  
  
  
  
  
  
    
      <form action="https://www.google.com/search" method="get">
        <fieldset role="search">
          <input type="hidden" name="sitesearch" value="away0x.github.io" />
    
          <input class="search" type="text" name="q" results="0" placeholder="Search"/>
        </fieldset>
      </form>
  
<ul class="main-navigation">
  <li><a href="/blog/archives">Archives</a></li>
  <!-- <li><a href="/blog/categories/ios">iOS</a></li> -->
  <li><a href="/blog/categories/objectivec">Objective-C</a></li>
  <li><a href="/blog/categories/frontend">Frontend</a></li>
  <li><a href="/blog/categories/ruby">Ruby</a></li>
  <li><a href="/blog/categories/rust">Rust</a></li>
  <li><a href="/resources">Resources</a></li>
  <li><a href="/about">About</a></li>
</ul>
</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      
        <h1 class="entry-title">Rust - Ownership, Borrowing</h1>
      
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2021-10-02T08:00:00+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2021</span></span> <span class='time'>8:00 am</span></time>
        
        
      </p>
    
  </header>


<div class="entry-content"><!-- more -->


<ul>
<li><a href="#Ownership">Ownership</a></li>
<li><a href="#Borrowing">Borrowing</a></li>
</ul>


<h2><h2 id="Ownership">Ownership</h2></h2>

<blockquote><p>所有权是 Rust 最独特的特性，它让 Rust 无需 GC 就可以保证内存安全</p></blockquote>

<ul>
<li>所有程序在运行时都必须管理它们使用计算机内存的方式

<ul>
<li>有些语言有垃圾收集机制，在程序运行时，它们会不断的寻找不再使用的内存</li>
<li>而有些语言中，程序员必须显式地分配和释放内存</li>
<li>Rust 则时通过所有权系统来管理，其中包含一组编译器在编译时检查的规则, 当程序运行时，所有权特性不会减慢程序的运行速度 (因为 Rust 把内存管理相关的工作都提前到了编译时)</li>
</ul>
</li>
</ul>


<h3>Stack vs Heap</h3>

<p>在 Rust 这样的系统级编程语言来说，一个值是在 stack 上还是在 heap 上对语言的行为和你为什么要做某些决定是由很大的影响的</p>

<ul>
<li>Stack 会按值的接收顺序来存储，按相反的顺序将它们移除 (后进先出, LIFO)

<ul>
<li>添加数据(压入栈)，移除数据(弹出栈)</li>
<li><strong>所有存储在 Stack 上的数据必须拥有已知的固定的大小</strong></li>
</ul>
</li>
<li>编译时大小未知的数据或运行时大小可能发生改变的数据必须放在 heap 上</li>
</ul>


<h4>存储数据</h4>

<ul>
<li>Heap 对内存的组织性差一些

<ul>
<li>当把数据放入 heap 时，会请求一定数量的空间</li>
<li>操作系统在 heap 里找到一块足够大的空间，把它标记在用，并返沪一个指针，也就是这个空间的地址 (这个过程叫做在 heap 上进行<strong>分配</strong>)</li>
</ul>
</li>
<li>把值压到 stack 上不叫分配</li>
<li>因为指针是已知固定大小, 可以把指针存放在 stack 上

<ul>
<li>但如果想要实际数据，必须使用指针来定位</li>
</ul>
</li>
<li>把数据压到 stack 上要比 heap 上分配快得多 (因为操作系统不需要寻找用来存储新数据的空间，那个位置永远都在 stack 的顶端)</li>
<li>在 heap 上分配空间需要更多的工作 (操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配)</li>
</ul>


<h4>访问数据</h4>

<ul>
<li>访问 heap 中的数据要比访问 stack 中的数据慢，因为需要通过指针才能找到 heap 中的数据

<ul>
<li>对于现代处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快</li>
</ul>
</li>
<li>如果数据存放的距离比较近，那么处理器的处理速度就会更快一些 (stack 上)</li>
<li>如果数据之间的距离比较远，那么处理速度就会慢一些 (heap 上)

<ul>
<li>在 heap 上分配大量的空间也是需要时间的</li>
</ul>
</li>
</ul>


<h4>函数调用</h4>

<p>当代码调用函数时，值被传入函数(也包括指向 heap 的指针). 函数本地的变量被压到 stack 上. 当函数结束后，这些值会从 stack 上弹出</p>

<h3>所有权解决的问题</h3>

<blockquote><p>管理 heap 数据是所有权存在的原因</p></blockquote>

<ol>
<li>跟踪代码的哪些部分正在使用 heap 的哪些数据</li>
<li>最小化 heap 上的重复数据量</li>
<li>清理 heap 上未使用的数据以避免空间不足</li>
</ol>


<h3>所有权规则 (保证单一所有权)</h3>

<ul>
<li>每个值都有一个变量，这个变量是该值的所有者</li>
<li>每个值同时只能有一个所有者 (Move 语义)</li>
<li>当所有者超出作用域 (scope) 时，该值将被删除</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// s 不可用</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;s&quot;</span><span class="p">;</span> <span class="c1">// s 可用</span>
</span><span class='line'>    <span class="c1">// s 可用</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// s 作用域结束，s 不可用</span>
</span></code></pre></td></tr></table></div></figure>


<h4>从 String 类型了解所有权</h4>

<ul>
<li>String 比那些标量类型更复杂</li>
<li>字符串字面值: 程序里手写的那些字符串值，它们是不可变的 (<code>&amp;str</code> 类型)</li>
<li>Rust 还有第二种字符串类型: String

<ul>
<li>在 heap 上分配，能够存储在编译时未知数量的文本</li>
</ul>
</li>
<li>String 类型的值是可以修改的，而字符串字面值却不能修改

<ul>
<li>这是因为它们处理内存的方式不同</li>
<li>字符串字面值，在编译时就知道它的内容，其文本内容直接被硬编码到最终的可执行文件里 (速度快，高效是因为其不可变)</li>
<li>String 类型，为了支持可变性，需要在 heap 上分配内存来保存编译时未知的大小内容

<ol>
<li>操作系统必须在运行时来请求数据 (通过调用 <code>String::from</code> 实现)</li>
<li>当用完 String 后，需要使用某种方式将内存返回给操作系统

<ul>
<li>在拥有 GC 的语言中，GC 会跟踪并清理不再使用的内存</li>
<li>没有 GC 就需要我们去识别内存何时不再使用，并调用代码将它返回

<ul>
<li>如忘了，就会浪费内存</li>
<li>如提前做了，变量就会非法</li>
<li>如果做了两次，也是 bug，必须一次分配对应一次释放</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>Rust 采用了不同的内存管理方式: 对于某个值来说，当拥有它的变量走出作用域范围时，内存会立即自动的交还给操作系统

<ul>
<li>离开作用域时，Rust 会调用该变量的 drop 方法，释放内存</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;s&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">s</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&quot;ss&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// s 离开作用域，调用 drop 函数释放内存，之后将不可用</span>
</span></code></pre></td></tr></table></div></figure>


<h4>变量和数据交互的方式: Move</h4>

<ul>
<li>多个变量可以与同一个数据使用一种独特的方式来交互</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// 整数是已知固定大小的简单的值，这两个 5 被压到 stack 中</span>
</span><span class='line'><span class="kd">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="kd">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 复制了一个 5，压入栈</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// String 类型由三部分组成:</span>
</span><span class='line'><span class="c1">// 1. 指向存放字符串内容的内存的指针</span>
</span><span class='line'><span class="c1">// 2. 长度 len (存放字符串内容所需的字节数)</span>
</span><span class='line'><span class="c1">// 3. 容量 capacity (String 从操作系统总共获得内存的总字节数)</span>
</span><span class='line'><span class="c1">// 上面这些内容放在 stack 中</span>
</span><span class='line'><span class="c1">// 存放字符串内容的部分在 heap 上</span>
</span><span class='line'><span class="kd">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;s&quot;</span><span class="p">);</span>
</span><span class='line'><span class="kd">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 其他语言的做法</span>
</span><span class='line'><span class="c1">// 当把 s1 赋值给 s2 时，String 在 stack 中存储的东西就被复制了一份给 s2 了</span>
</span><span class='line'><span class="c1">// 但是 heap 的内容不复制，所以 s1 s2 的指针所指向的 heap 内存是一样的</span>
</span><span class='line'><span class="c1">// 当变量离开作用域时，Rust 会自动调用 drop 函数，并将变量使用的 heap 内存释放</span>
</span><span class='line'><span class="c1">// **当 s1 s2 离开作用域时，它们都会尝试释放相同的内存**</span>
</span><span class='line'><span class="c1">//  - 这会引起二次释放的 bug (double free)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>所以为了避免以上其他语言会发生的问题，保证内存安全:

<ul>
<li>Rust 没有尝试复制被分配的内存</li>
<li>s1 赋值给 s2 时，Rust 让 s1 失效

<ul>
<li>当 s1 离开作用域时，Rust 不需要释放任何东西了 (不会发生其他语言的那种二次释放的 bug 了)</li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kd">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;s&quot;</span><span class="p">);</span>
</span><span class='line'><span class="kd">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span> <span class="c1">// s1 失效了，move 给了 s2</span>
</span><span class='line'>
</span><span class='line'><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">s1</span><span class="p">);</span> <span class="c1">// s1 不可用, 报错</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>一般将复制指针、长度、容量视为浅拷贝，但由于 Rust 让 s1 失效了，所以使用 Move 来称呼这个行为</li>
</ul>


<h4>变量和数据交互的方式: Clone</h4>

<ul>
<li>如果真的想对 heap 上的数据进行深拷贝，而不仅仅是拷贝 stack 上的数据，可以使用 <strong>clone</strong> 方法</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kd">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;s&quot;</span><span class="p">);</span>
</span><span class='line'><span class="kd">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{} {}&quot;</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span> <span class="c1">// ok</span>
</span></code></pre></td></tr></table></div></figure>


<h4>变量和数据交互的方式: Copy</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// 已知大小的数据会存放在 stack 中，它们这样的操作是 copy 行为，会将 stack 上的数据 copy 一份</span>
</span><span class='line'><span class="kd">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'><span class="kd">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 复制了一个 5，压入栈</span>
</span><span class='line'>
</span><span class='line'><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{} {}&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// ok</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Copy trait: 可以用于像整数这样完全存放在 stack 上面的类型</li>
<li>如果一个类型实现了 Copy trait，那么旧的变量在赋值后仍然可用</li>
<li>如果一个类型或者该类型的一部分实现了 Drop trait，那么 Rust 不允许让它再去实现 Copy trait 了</li>
</ul>


<h5>一些拥有 Copy trait 的类型</h5>

<ul>
<li>任何简单标量的组合类型都是可 Copy 的</li>
<li>任何需要分配内存或者某种资源的都不是可 Copy 的</li>
<li>一些拥有 Copy trait 的类型

<ul>
<li>所有的整数类型，例如 u32</li>
<li>所有的浮点类型，例如 f64</li>
<li>bool</li>
<li>char</li>
<li>Tuple，如果其拥有的所有字段都是可 Copy 的

<ul>
<li><code>(i32, i32)</code> 是 Copy</li>
<li><code>(i32, String)</code> 不是 Copy</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>所有权与函数</h4>

<ul>
<li>在语义上，将值传递给函数和把值赋值给变量是类似的

<ul>
<li>将值传递给函数将发生移动或复制</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">take_ownership</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">// s move 到了函数中</span>
</span><span class='line'>    <span class="c1">// s 不可用</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'>    <span class="n">make_copy</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// x copy 到了函数中</span>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;x: {}&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// x 还是可用</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">make_ownership</span><span class="p">(</span><span class="n">some_str</span><span class="o">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">some_str</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">make_copy</span><span class="p">(</span><span class="n">some_num</span><span class="o">:</span> <span class="kt">i32</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span> <span class="n">some_num</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>函数在返回值的过程中同样也会发生所有权的转移</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">gives_ownership</span><span class="p">();</span> <span class="c1">// 函数里面的返回值 move 给了 s1</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">takes_and_gives_back</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span> <span class="c1">// s2 move 进了函数，又 move 给了 s3</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">gives_ownership</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">some_str</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">some_str</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">takes_and_gives_back</span><span class="p">(</span><span class="n">a</span><span class="o">:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">a</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>一个变量的所有权总是遵循同样的模式

<ul>
<li>把一个值赋给其他变量时就会发生移动</li>
<li>当一个包含 heap 数据的变量离开作用域时，它的值就会被 drop 函数清理，除非数据的所有权移动到另一个变量上</li>
</ul>
</li>
</ul>


<h2><h2 id="Borrowing">Borrowing</h2></h2>

<ul>
<li><code>&amp;</code> 符号表示引用，允许你引用某些值而不取得其所有权</li>
<li>引用作为函数参数的行为叫做借用

<ul>
<li>和变量一样，引用默认是不可变的</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">calc_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span> <span class="c1">// 将 s1 的引用传入了函数，没有发生所有权的转移</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}, {}&quot;</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span> <span class="c1">// 由于 s1 所有权没有转移，所以其在该作用域内还是存活的</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">calc_len</span><span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">usize</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// s.push_str(&quot;ss&quot;) // 报错，引用默认是不可变的</span>
</span><span class='line'>    <span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="kd">let</span> <span class="k">mut</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">);</span>
</span><span class='line'><span class="kd">let</span> <span class="n">len</span> <span class="o">=</span> <span class="n">calc_len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">s1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">fn</span> <span class="n">calc_len</span><span class="p">(</span><span class="n">s</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">usize</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">s</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&quot;ss&quot;</span><span class="p">);</span> <span class="c1">// 借用到的是可变引用，可以修改</span>
</span><span class='line'>    <span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>可变引用:</h3>

<ul>
<li><strong>限制1: 在特定作用域内，对某一块数据，只能有一个可变的引用</strong>

<ul>
<li>好处: 编译时就可以防止数据竞争</li>
<li>在一个作用域内，仅允许一个活跃的可变引用。所谓活跃，就是真正被使用来修改数据的可变引用，如果只是定义了，却没有使用或者当作只读引用使用，不算活跃</li>
</ul>
</li>
<li>以下三种情况会发生数据竞争 (这些数据竞争的情况，运行时是很难发现的，所以 Rust 在设计上避免了这种情况)

<ol>
<li>两个或多个指针同时访问同一个数据</li>
<li>至少有一个指针用于写入数据</li>
<li>没有使用任何机制来同步对数据的访问</li>
</ol>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="c1">// 可以通过创建新的作用域，来允许非同时的创建多个可变引用</span>
</span><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kd">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>限制2: 可变引用（写）和只读引用（读）是互斥的关系，就像并发下数据的读写互斥那样</strong>

<ul>
<li>只有多个不可变的引用是可以的</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// 不可以，当前作用域已经有不可变引用了</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">let</span> <span class="k">mut</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</span><span class='line'>  <span class="kd">let</span> <span class="n">last</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">last</span><span class="p">();</span> <span class="c1">// 访问不可变引用</span>
</span><span class='line'>  <span class="n">arr</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 访问可变引用</span>
</span><span class='line'>  <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;last: {:?}&quot;</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span> <span class="c1">// 访问不可变引用 (报错), 此时之前的可变引用</span>
</span><span class='line'>  <span class="c1">// 该例中可变不可变相互纠缠, 相互交叉, 破坏了互斥原则, 所以报错</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 修改为下</span>
</span><span class='line'><span class="c1">// 不可变和可变引用的界限分明了, 编译通过</span>
</span><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">let</span> <span class="k">mut</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</span><span class='line'>  <span class="kd">let</span> <span class="n">last</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">last</span><span class="p">();</span> <span class="c1">// 访问不可变引用</span>
</span><span class='line'>  <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;last: {:?}&quot;</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span> <span class="c1">// 访问不可变引用, print &quot;last: Some(3)&quot;</span>
</span><span class='line'>  <span class="c1">// 不可变引用访问结束, 此时再访问可变引用, 就不冲突了</span>
</span><span class='line'>  <span class="n">arr</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// 访问可变引用</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">data1</span> <span class="o">=</span> <span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span> <span class="c1">// 访问了 data 的不可变引用</span>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;data[0]: {:p}&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.</span><span class="mi">100</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 如果继续添加元素，堆上的数据预留的空间不够了，就会重新分配一片足够大的内存，</span>
</span><span class='line'>        <span class="c1">// 把之前的值拷过来，然后释放旧的内存。</span>
</span><span class='line'>        <span class="c1">// 这样就会让 data1 中保存的 &amp;data[0] 引用失效，导致内存安全问题</span>
</span><span class='line'>        <span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 访问了 data 的可变引用</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;data[0]: {:p}&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class='line'>    <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;boxed: {:p}&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data1</span><span class="p">);</span> <span class="c1">// 访问了 data 的不可变引用 (和可变引用互斥了, 报错)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>悬垂引用 Dangling References</h3>

<blockquote><p>一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其他人使用了</p></blockquote>

<ul>
<li>Rust 里，编译器可以保证引用永远都不是悬空引用

<ul>
<li>如果引用了某些数据，编译器将保证在引用离开作用域之前数据不会离开作用域</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">fn</span> <span class="n">dangle</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="o">&amp;</span><span class="n">s</span> <span class="c1">// 报错, 离开作用域 s 被销毁了，s 的引用会指向一个已经被释放的空间，所以编译器不允许返回 &amp;s</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>引用的规则总结</h3>

<ul>
<li>在任何给定的时刻，只能满足以下条件之一

<ol>
<li>一个可变的引用</li>
<li>任意数量不可变的引用</li>
</ol>
</li>
<li>引用必须一直有效</li>
<li>引用和指针的主要区别

<ol>
<li>引用不可为空</li>
<li>拥有生命周期</li>
<li>受借用检查器保护不会发生悬垂指针等问题</li>
</ol>
</li>
</ul>

</div>


  <footer>
    <p class="meta">
      
  



  <span class="byline author vcard">Authored by <span class="fn">
  
    TongWu
  
  </span></span>


      




<time class='entry-date' datetime='2021-10-02T08:00:00+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2021</span></span> <span class='time'>8:00 am</span></time>
      
      

<span class="categories">
  
    <a class='category' href='/blog/categories/rust/'>rust</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://away0x.github.io/blog/2021/10/02/rust-ownership-borrowing/" data-via="" data-counturl="http://away0x.github.io/blog/2021/10/02/rust-ownership-borrowing/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2021/10/01/rust-install-basic/" title="Previous Post: Rust - Install, Basic">&laquo; Rust - Install, Basic</a>
      
      
        <a class="basic-alignment right" href="/blog/2021/10/03/rust-slice-struct-enum/" title="Next Post: Rust - Slice, Struct, Enum">Rust - Slice, Struct, Enum &raquo;</a>
      
    </p>
  </footer>
</article>


</div>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2022 - TongWu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>
<script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1280412127'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1280412127%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
<style>
  span[id^="cnzz_stat_icon"] {
    display: none;
  }
</style>
</footer>
  










  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
